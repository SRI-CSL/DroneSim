Eventually timeEffectA probably needs the envt argument or
it could be passed the results of doUnitEnvAct.

For now vlift, vland are be global constants.

Probably should rethink how this is done.

******************************
Added to soft-agents.maude

#  op _@_ : Action Time -> DEvent .  --- for action that continues til done or dropped
#  eq getTime(act @ t) = t .

#  eq effActs((act @ t ) evs)  =  (act @ t ) effActs(evs) .

#  eq mte((act @ t ) evs) = mte(evs) . --- actions are performed with timeStep


#  eq timeEffect((act @ t) evs, u) 
   =  (if (t >= u) 
       then (act @ (t monus u)) timeEffect(evs,u)
       else timeEffectA(act, u monus t)  timeEffect(evs,u)
       fi)
   
#  op timeEffectA : Action Time -> Event .

********************
# added to tasks-sitl

  op land : Id Nat -> Action   -- land(id,alt) starting altitude  

fixed occurrences of land in sitlAct and helpers
doTask must remove actions that pass the isDone test 
from devs -- probably better done by sitlAct 
-- which could return EventSetKB rather than ActionKB


********************
# actions in SitlPatrolBot   

ceq timeEffectA(continue(id) , u) = none .
  ceq timeEffectA(stop(id), u) = none .  
 
  ceq timeEffectA(takeOff(id,alt), u) =
     (if  alt1 <= 0
     then none
     else takeOff(id, alt1) ; 0
     fi) 
  if alt1 := rat(float(alt) - (float(u) * vlift)) .


eq timeEffectA(land(id,alt), u) =
     if alt1 <= 0
     then none **** landed
     else land(id, alt1) ; 0
     fi
 if alt1 := rat(float(alt) - (float(u) * vland))
     
ceq timeEffectA(mv(id,dir(x,y,x),v), u) =
     (if d < v * float(u)
     then none  --- will finish in u time units
     else mv(id, dir(x monus dx, y monus dy, z monus dz),v) ; 0
     fi) 
if d := sqrt((x * x) + (y * y) + (z * z))     
/\ dv := (v / d) * float(u)    ---- d/v secs to complete v/d portion per sec
/\ dx := dv * x
/\ dx := dv * x
/\ dy := dv * y .
  


*************************
****	op doUnitEnvAct : Time KB EventSet -> KB .

 
in actions.maude add (at the end)

 ceq doUnitEnvAct(t, ekb, (mv(id,dir(ffx,ffy,ffz),v) @ 0 ) evs)
   = doUnitEnvAct(t, addK(ekb,(atloc(id,l3) @ s(t)) 
                              energy(id,e0) @ s(t)) , evs)
   if l0 := getLoc(id,ekb)
   /\ l1 := doMvU(l0,dir(ffx,ffy,ffz),v) 
   /\ e := getEnergy(id,ekb)
   /\ e0 := energyMvU(e,v,1)
   /\ l3 := (if occupied(l1,ekb) then l0 else l1 fi)
  .

  op energyMvU : FiniteFloat FiniteFloate Nat -> FiniteFloat .
  op energyMvU(e,v,t) = max(e - costMv,0.0) .  ---!!!fix

  op doMvU : Loc Dir FiniteFloat -> Loc .
  ceq doMvU(l0,dir(ffx,ffy,ffz),v) =
    (if (d < v )
  	then addLoc(l0,dir(ffx,ffy,ffz))
  	else addLoc(l0, dir(dx,dy,dz))
    fi)
  if d := sqrt((ffx * ffx) + (ffy * ffy) + (ffz * ffz))     
  /\ dv := (v / d)     ---- d/v secs to complete v/d portion per sec
  /\ dx := dv * ffx
  /\ dy := dv * ffy
  /\ dz := dv * ffz.

  op addLoc : Loc Dir -> Loc .
  ceq addLoc(l0,dir(ffx,ffy,ffz)) =  {l1,msen2grid(l1)}
  if senLoc(ffx0,ffy0,ffz0) := getSenLoc(l0)
  /\ l1 := senLoc(ffx0 + ffx,ffy0 + ffy, ffz0 + ffz) .

 ceq doUnitEnvAct(t, ekb, (takeOff(id,alt) @ 0 ) evs)
   = doUnitEnvAct(t, addK(ekb,(atloc(id,l1) @ s(t)) 
                              energy(id,e0) @ s(t)) , evs)
 if l0 := getLoc(id,ekb)
 /\ l1 := doTakeOffU(l0,alt) 
 /\ e := getEnergy(id,ekb)
 /\ e0 := energyTakeOff(e,vlift)
  .

***( 
 alt = 2  v = 3  alt - v neg so add alt
 alt = 2 v = 1    add v
)

  op energyTakeOffU : FiniteFloat FiniteFloat  -> FiniteFloat .
  op energyTakeOffU(e,v) = max(e - costMv,0.0) .  ---!!!fix

  ceq doTakeOffU(l0,alt) = {senl1, msens(senl1)}
  if senLoc(ffx0,ffy0,ffz0) := getSenLoc(l0)
  /\ ffz := if float(alt) <= vlift then ffz0 + float(alt) else ffz0 + vlift .
  /\ senl1 := senLoc(ffx0,ffy0,ffz) .

 ceq doUnitEnvAct(t, ekb, (land(id,alt) @ 0 ) evs)
   = doUnitEnvAct(t, addK(ekb,(atloc(id,l1) @ s(t)) 
                              energy(id,e0) @ s(t)) , evs)
   if l0 := getLoc(id,ekb)
   /\ l1 := doLandU(l0,alt) 
   /\ e := getEnergy(id,ekb)
   /\ e0 := energyLandU(e,vlift)
  .

***( 
 alt = 2  v = 3  alt - v neg so subtract alt
 alt = 2 v = 1    substract v
)

  op energyLandU : FiniteFloat FiniteFloat  -> FiniteFloat .
  op energyLandU(e,v) = max(e - costMv,0.0) .  ---!!!fix

  ceq doLandU(l0,alt) = {senl1, msens(senl1)}
  if senLoc(ffx0,ffy0,ffz0) := getSenLoc(l0)
  /\ ffz := if float(alt) <= vlift then ffz0 - float(alt) else ffz0 - vlift .
  /\ senl1 := senLoc(ffx0,ffy0,ffz) .
