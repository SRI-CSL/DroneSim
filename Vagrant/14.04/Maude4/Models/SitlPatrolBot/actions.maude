fmod MODEL-ACTIONS is
  inc MODEL-TASKS .

  vars t t' t0 t1 t2 : Time .
  var nzt : NzTime .
  vars id id' id0 : Id .
  vars l0 l1 l2 l3 loc : Loc .
  vars lkb ekb ekb' ekb0 : KB .
  var dir : Dir .
  var b b0 b1 b2 : Bool .
  var evs : EventSet .
  vars e e0 v : FiniteFloat .
	var n u alt : Nat .
  vars senl0 senl1 senl2  : SenLoc .
  vars gl0 gl1 gl2 : GridLoc .

  var alt1 : Rat .
  vars ffx ffy ffz ffx0 ffy0 ffz0 dx dy dz d dv : FiniteFloat .
  
******* timeEffectA for sitl style actions

  eq timeEffectA(continue(id) , u) = none .
  eq timeEffectA(stop(id), u) = none .  
 
  ceq timeEffectA(takeOff(id,alt), u) =
     (if  alt1 <= 0
     then none
     else takeOff(id, alt1) @ 0
     fi) 
  if alt1 := rat(float(alt) - (float(u) * vlift)) .

  ceq timeEffectA(land(id,alt), u) =
       (if alt1 <= 0
       then none **** landed
       else land(id, alt1) @ 0
       fi)
   if alt1 := rat(float(alt) - (float(u) * vland)) .
     
  ceq timeEffectA(mv(id,dir(ffx,ffy,ffz),v), u) =
       (if d < v * float(u)
       then none  --- will finish in u time units
       else mv(id, dir(ffx - dx, ffy - dy, ffz - dz),v) @ 0
       fi) 
  if d := sqrt((ffx * ffx) + (ffy * ffy) + (ffz * ffz))     
  /\ dv := (v / d) * float(u)  ---- d/v secs to do v/d portion per sec
  /\ dx := dv * ffx
  /\ dy := dv * ffy
  /\ dz := dv * ffz .
  

**** implicit that id =/= id' since shouldn't be two class facts for id
**** using same t means locs are refreshed at each time step
 eq okEnv(class(id,Bot)  (atloc(id, l1) @ t) 
                 class(id',Bot) (atloc(id',l1) @ t) ekb) = false .
 eq okEnv(ekb) = true [owise] .


**** incase there is only one bot l3 should be l2, no occupation conflict
**** performs actions for one-time unit -- but SEQUENTIALLY!! see below
****  op doUnitEnvAct : Time KB EventSet -> KB .

 ceq doUnitEnvAct(t, ekb, (mv(id,dir,v) @ 0 ; nzt) evs)
   = doUnitEnvAct(t, addK(ekb,(atloc(id,l3) @ s(t)) 
                              energy(id,e0) @ s(t)) , evs)
   if l0 := getLoc(id,ekb)
   /\ l1 := doMv(l0,dir,v) 
   /\ e := getEnergy(id,ekb)
   /\ e0 := max(e - costMv,0.0)
   /\ l2 := windEffect(l1,ekb) 
   /\ l3 := 
      (if occupied(l1,ekb) then l0 else (if occupied(l2,ekb) then l1 else l2 fi) fi)
  .

 ceq doUnitEnvAct(t, ekb, (charge(id) @ 0 ; nzt) evs)
   = doUnitEnvAct(t,
      addK(ekb,energy(id,min(e + chargeUnit,maxCharge)) @ s t), evs)
   if (energy(id,e) @ t0) (atloc(id,l0) @ t1) 
	    (atloc(id0,l1) @ t2) class(id0,Station) ekb0 := ekb
   /\ equiv(l0,l1)
	   .

  eq doUnitEnvAct(t, ekb, evs) = ekb [owise] .

  op wind : Loc Dir Nat -> Info .
  op wind : Dir Nat -> Info .
  op windEffect : Loc KB -> Loc .
  eq windEffect(l0, (clock(t)) (wind(l0,dir,n) @ t0) ekb) =
         (if t rem n == 0 then doMv(l0,dir,gridStepX) else l0 fi) .
  ceq windEffect(l0, (clock(t)) (wind(dir,n) @ t0) ekb) = doMv(l0,dir,gridStepX)
   if t rem n == 0 .
  eq windEffect(l0,ekb) = l0 [owise] .
 
	
***(
--- modified location by wind
 ceq windEffect(l0, (clock(t)) ekb) = doMv(l0,S)
  if t rem 13 == 0 .
 ceq windEffect(l0, (clock(t)) ekb) = doMv(l0,N)
  if t rem 17 == 0 .
)


************ sitl like unit actions

  ceq doUnitEnvAct(t, ekb, (mv(id,dir(ffx,ffy,ffz),v) @ 0 ) evs)
   = doUnitEnvAct(t, addK(ekb,(atloc(id,l3) @ s(t)) 
                              energy(id,e0) @ s(t)) , evs)
   if l0 := getLoc(id,ekb)
   /\ l1 := doMvU(l0,dir(ffx,ffy,ffz),v) 
   /\ e := getEnergy(id,ekb)
   /\ e0 := energyMvU(e,v)
   /\ l3 := (if occupied(l1,ekb) then l0 else l1 fi)
  .

  op energyMvU : FiniteFloat FiniteFloat  -> FiniteFloat .
  eq energyMvU(e,v) = max(e - costMv,0.0) .  ---!!!fix

  op doMvU : Loc Dir FiniteFloat -> Loc .
  ceq doMvU(l0,dir(ffx,ffy,ffz),v) =
    (if (d < v )
  	then addLoc(l0,dir(ffx,ffy,ffz))
  	else addLoc(l0, dir(dx,dy,dz))
    fi)
  if d := sqrt((ffx * ffx) + (ffy * ffy) + (ffz * ffz))     
  /\ dv := (v / d)     ---- d/v secs to complete v/d portion per sec
  /\ dx := dv * ffx
  /\ dy := dv * ffy
  /\ dz := dv * ffz
  .

  op addLoc : Loc Dir -> Loc .
  ceq addLoc(l0,dir(ffx,ffy,ffz)) =  {senl1,msen2grid(senl1)}
  if senLoc(ffx0,ffy0,ffz0) := getSenLoc(l0)
  /\ senl1 := senLoc(ffx0 + ffx,ffy0 + ffy, ffz0 + ffz) .

 ceq doUnitEnvAct(t, ekb, (takeOff(id,alt) @ 0 ) evs)
   = doUnitEnvAct(t, addK(ekb,(atloc(id,l1) @ s(t)) 
                              energy(id,e0) @ s(t)) , evs)
 if l0 := getLoc(id,ekb)
 /\ l1 := doTakeOffU(l0,alt) 
 /\ e := getEnergy(id,ekb)
 /\ e0 := energyTakeOffU(e,vlift)
  .

***( 
 alt = 2  v = 3  alt - v neg so add alt
 alt = 2 v = 1    add v
)

  op energyTakeOffU : FiniteFloat FiniteFloat  -> FiniteFloat .
  eq energyTakeOffU(e,v) = max(e - costMv,0.0) .  ---!!!fix

  op doTakeOffU : Loc Nat -> Loc .
  ceq doTakeOffU(l0,alt) = {senl1, msen2grid(senl1)}
  if senLoc(ffx0,ffy0,ffz0) := getSenLoc(l0)
  /\ ffz := (if float(alt) <= vlift 
            then ffz0 + float(alt) 
            else ffz0 + vlift 
            fi)
  /\ senl1 := senLoc(ffx0,ffy0,ffz) .


 ceq doUnitEnvAct(t, ekb, (land(id,alt) @ 0 ) evs)
   = doUnitEnvAct(t, addK(ekb,(atloc(id,l1) @ s(t)) 
                              energy(id,e0) @ s(t)) , evs)
   if l0 := getLoc(id,ekb)
   /\ l1 := doLandU(l0,alt) 
   /\ e := getEnergy(id,ekb)
   /\ e0 := energyLandU(e,vlift)
  .

***( 
 alt = 2  v = 3  alt - v neg so subtract alt
 alt = 2 v = 1    substract v
)

  op energyLandU : FiniteFloat FiniteFloat  -> FiniteFloat .
  eq energyLandU(e,v) = max(e - costMv,0.0) .  ---!!!fix

  op doLandU : Loc Nat -> Loc .
  ceq doLandU(l0,alt) = {senl1, msen2grid(senl1)}
  if senLoc(ffx0,ffy0,ffz0) := getSenLoc(l0)
  /\ ffz := (if float(alt) <= vlift 
            then ffz0 - float(alt) 
            else ffz0 - vlift fi)
  /\ senl1 := senLoc(ffx0,ffy0,ffz) .


endfm

