mod SCENARIO is
  inc MODEL-TASKS .
  inc SOFT-AGENT-RULES .
  inc PRETTY .
  --- inc SOLVE-SCP{valuation2valpatrolonly} . 
  --- inc SOLVE-SCP{valuation2valpatrolenergy} . 
	--- inc SOLVE-SCP{valuation2valpatrolenergyconservative} . 

vars n n' t t0 m : Nat .
vars i j x y z : Int .
vars sx sy sz dx dy dz v e c : FiniteFloat .
var dir : Dir .
vars wkb kb lkb ekb : KB .
var aconf : Conf .
var attrs : AttributeSet .
var id eid : Id .
var ids : IdSet .
var cl : Class .
var l home loc : Loc .
var a : Int .
var locs : LocList .

op bound : Nat -> ConfElt .

eq comDistance = 2 .

eq senXLow = 0.0 .
eq senYLow = 0.0 .
eq senZLow = 0.0 .

---- Grid size
eq gridStepX = 1.0 .
eq gridStepY = 1.0 .
eq gridStepZ = 1.0 .
 
eq chargeUnit = 5.0 .
eq maxCharge = 20.0 .

eq botDelay = 1 .
eq costMv(v) = 0.06 . --- consumes x percent battery per meter
eq periodicity = 60 .


***(
Performed one experiment with dronekit copter at velocity 5m/s
and altitude 5m

Takeoff : 100% -> 97%
70m  : 96% -> 91%
100m : 91% -> 85%
100m : 84% -> 78%
100m : 77% -> 71%
100m : 70% -> 65%
70m : 64% -> 59%
Landing/Disarm : 58% -> 55%


)

op b : Nat -> Id .
op st : Nat -> Id .
op eI : -> Id .
    
op mkLoc : FiniteFloat FiniteFloat FiniteFloat -> Loc .
eq mkLoc(sx,sy,sz) = {senLoc(sx,sy,sz),msen2grid(senLoc(sx,sy,sz))} .

op mkBekb : Nat FiniteFloat FiniteFloat FiniteFloat FiniteFloat FiniteFloat 
             -> KB .
eq mkBekb(n,sx,sy,sz,v,e) = 
    (atloc(b(n),mkLoc(sx,sy,sz)) @ 0)
    class(b(n),Bot) (energy(b(n),e) @ 0) (targetVel(b(n),v) @ 0) .

op mkBkb : Nat FiniteFloat FiniteFloat FiniteFloat FiniteFloat FiniteFloat FiniteFloat Int LocList -> KB .
eq mkBkb(n,sx,sy,sz,v,e,c,a,locs) = 
    mkBekb(n,sx,sy,sz,v,e) myAlt(b(n),a) (caution(b(n),c) @ 0)
    myHome(b(n),mkLoc(sx,sy,sz)) (targets(b(0),locs,nil) @ 0) 
    (rand(b(n),0) @ 0)(visited(b(n),nil) @ 0) 
    (lastVisit(b(n),mkLoc(sx,sy,sz)) @ 0)
    (mkCountVisits(n,locs))
     clock(0) .

op mkCountVisits : Nat LocList -> KB .
eq mkCountVisits(n,loc ; locs) 
 = (countVisit(b(n),loc,0) @ 0) mkCountVisits(n,locs) .
eq mkCountVisits(n,nil) = none .

op mkB : Nat FiniteFloat FiniteFloat FiniteFloat FiniteFloat FiniteFloat FiniteFloat Int LocList -> Agent .
eq mkB(n,sx,sy,sz,v,e,c,a,locs) =
 [b(n) : Bot | lkb : mkBkb(n,sx,sy,sz,v,e,c,a,locs),
               ckb : none, evs : (tick @ 0)] .
 
ops mkE1 : Nat FiniteFloat FiniteFloat FiniteFloat FiniteFloat FiniteFloat -> Env .  **** bot env
eq mkE1(n,sx,sy,sz,v,e) = [eI | clock(0) mkBekb(n,sx,sy,sz,v,e)  ] .

ops locs1 locs2 : -> LocList .
eq locs1 = mkLoc(50.0,-50.0,5.0) ; mkLoc(50.0,50.0,5.0)
           ; mkLoc(-50.0,50.0,5.0) ; mkLoc(-50.0,-50.0,5.0) .

eq locs2 =  mkLoc(30.0,-30.0,5.0) ; 
            mkLoc(50.0,-10.0,5.0) ; mkLoc(50.0,15.0,5.0) ; 
            mkLoc(50.0,30.0,5.0) ; mkLoc(-15.0,10.0,5.0) ; 
            mkLoc(-30.0,30.0,5.0) ; mkLoc(-20.0,-10.0,5.0) ;
            mkLoc(-10.0,-10.0,5.0) .


--- energy parameter is not yet useful
ops conf1 conf2 conf3 conf4 : -> Conf .
****           (n,sx,sy,sz,  v,  e,   c,  a,locs) 
eq conf1 = mkB(0,0.0,0.0,0.0,5.0,100.0,70.0,5,locs1)
           mkE1(0,0.0,0.0,0.0,5.0,100.0) . 

eq conf2 = mkB(0,0.0,0.0,0.0,5.0,100.0,20.0,5,locs1)
           mkE1(0,0.0,0.0,0.0,5.0,100.0) . 

eq conf3 = mkB(0,0.0,0.0,0.0,5.0,100.0,20.0,5,locs2)
           mkE1(0,0.0,0.0,0.0,5.0,100.0) . 


ops asys1 asys2 asys3 asys4 : -> ASystem .
eq asys1 = { conf1 } .
eq asys2 = { conf2 } .
eq asys3 = { conf3 } .

ops asys asys2 : Nat -> ASystem .
eq asys(n) = { conf1 bound(n) } .

*** VN: For now ingnoring direction
op updateEkb : KB Id FiniteFloat FiniteFloat FiniteFloat FiniteFloat FiniteFloat FiniteFloat FiniteFloat FiniteFloat Nat -> KB .
***(
eq updateEkb(ekb,id,sx,sy,sz,dx,dy,dz,v,e,n) = 
      addK(ekb,
      (atloc(id,{senLoc(sx,sy,sz),sen2grid(senLoc(sx,sy,sz))}) @ s n)
      (vel(id,v) @ s n) (energy(id,e) @ s(n))) .
)
eq updateEkb(ekb,id,sx,sy,sz,dx,dy,dz,v,e,n) = 
      addK(ekb,
      (atloc(id,{senLoc(sx,sy,sz),msen2grid(senLoc(sx,sy,sz))}) @ s n)
      (vel(id,v) @ s n) (energy(id,e) @ s(n))) .


op getIds : ASystem -> IdSet .
eq getIds({ aconf }) = getIdsX(aconf, none)  .

op getIdsX : Conf IdSet -> IdSet .
eq getIdsX(aconf, ids) = ids [owise] .
eq getIdsX([id : cl | attrs] aconf, ids) = getIdsX(aconf, id ids) .

***()
op upDateRand : ASystem Nat -> ASystem .
eq upDateRand({[ b(0) : Bot | lkb : lkb, attrs] aconf}, n) =
               {[b(0) : Bot | lkb : upDateRandKB(lkb,n), attrs] aconf} .

op upDateRandKB  : KB Nat -> KB .
eq upDateRandKB((rand(id,n') @ t) lkb,n) = (rand(id,n' + n) @ t) lkb .
eq upDateRandKB(lkb,n) = lkb [owise] .

****
eq windThresh = round(float(rand.25) / 2.0) .
--- eq windThresh = 0 .
eq stopSimulation = 75.0 .

**** true if landed at home 
**** false owise

sort BoolRes .
**** bool indicates multi or single
**** res is string rep of answer 
op br : Bool String -> BoolRes .
op getObs : ASystem -> BoolRes .

op getObsHome : KB KB -> String .
eq getObsHome(lkb (pending(b(0),stop(b(0))) @  t) myHome(b(0),home), 
            ( atloc(b(0),loc) @ t0) ekb) = 
     (if (close(home,loc))
      then "(double 1)"
      else "(double 0)"
      fi) .
eq getObsHome(lkb,ekb) = "(double 0)" [owise] .

**** for GenericApprox
op getObs1 : Conf -> String .
eq getObs1([ id : Bot | lkb : lkb, attrs] [eid | ekb ] aconf ) 
      =  getObsHome(lkb,ekb) .
eq getObs1( aconf ) =  "(double 0)" [owise] .

**** for nGenericApprox
op getObsN : Conf -> String .
ceq getObsN([ id : Bot | lkb : lkb, attrs] [eid | ekb ] aconf )
    =  getObsHome(lkb,ekb) + " " + mkdouble(e)  + " " + mkdouble(float(m)) + " " + mkdouble(float(n))
 if kb (energy(id,e) @ t) := ekb 
 /\ m := findMin(id,lkb,100000) 
 /\ n := countTotal(id,lkb) .

op countTotal : Id KB -> Nat .
eq countTotal(id,(countVisit(id,loc,n) @ t) kb) 
 = n + countTotal(id,kb) .
eq countTotal(id,kb) = 0 [owise] .

--- eq getObsN( aconf ) = "(double 0) (double 0)" [owise] .  

op mkdouble : FiniteFloat -> String .
eq mkdouble(e) = 
  "(" + "double" + " " + makeString(decFloat(e,2)) + ")"  .

op getObsKB : KB KB -> Bool .
eq getObs({aconf}) = br(true,getObsN(aconf)) .

***(

eq getObs({[ b(0) : Bot | lkb : lkb, attrs] [eid | ekb ] aconf }) =
   getObsKB(lkb,ekb)  .
eq getObsKB(lkb (pending(b(0),stop(b(0))) @  t) myHome(b(0),home) , 
            ( atloc(b(0),loc) @ t0) ekb) = distance(home,loc) < 6 .
eq getObs({ aconf }) = false [owise] .
)
op getObsVisited : ASystem -> Nat .
op getObsEnergy : ASystem -> FiniteFloat .
eq getObsVisited({[ b(0) : Bot | lkb : ((visited(b(0),locs) @ t0) lkb), attrs] [eid | ekb ] aconf }) 
 = len(locs).
eq getObsEnergy({[ b(0) : Bot | lkb : lkb, attrs] [eid | ((energy(b(0),e) @ t) ekb) ] aconf }) = e .

endm

***(
mod SCENARIO-TEST is
inc SCENARIO .

ops ekbX lkbX : -> KB .
eq ekbX = clock(2) class(b(0),Bot) 
(atloc(b(0), {senLoc(-3.3238765597300002e-1,               
                    -1.5381881967200001e-2,1.01596260071e+1), 
              pt(-1,-1,10)})@ 2)
(energy(b(0), 8.9e+1)@ 2)
( vel(b(0),3.1622776601700001e-2)@ 2)
.

eq lkbX = (clock(2) class(b(0),Bot)
(atloc(b(0),{senLoc(-2.90255874395e-1,
                2.3696256801500001e-2,2.4112732708500001e-1),
                pt(-1,0,0)})@ 1)
    (energy(b(0), 9.9e+1)@ 1)
    (caution(b(0),5.0)@ 0)
    (vel(b(0),2.9631064780100003e-1)@ 1)
    (pending(b(0),takeOff(b(0),10))@ 1)
    (targets(b(0),
      {senLoc(1.0e+1,0.0,1.0e+1),pt(10,0,10)}) @ 0)  
    myHome(b(0),{senLoc(0.0,0.0,0.0),pt(0,0,0)})
    myAlt(b(0), 10)) .

*** evs :(tick @ 0)]

op lkbX2 : -> KB .
eq lkbX2 = proSensors(b(0), lkbX, getSensors(b(0),ekbX) ) .

endm
)


***(
**** for sitl -- can randomly pause -- running down battery
**** critical if stop and not home  meaning stopped with battery low
**** or critical if battery low

**** need to add rand counter to asys
**** op getObs : ASystem -> Bool .   **** ekb loc is home
**** op upDateRand : ASystem Nat -> ASystem .

mod SCENARIO-VER is
  inc SCENARIO .

  var aconf : Conf .
  var n : Nat .
  var ff : FiniteFloat .
  vars id eId : Id .
  var t : Time .
  var kb : KB .

  op monus : Nat -> Nat .
  eq monus(s n) = n .
  eq monus(0) = 0 .

  ops criticalConf goalConf : -> ConfElt .
  op critical : Conf -> Bool .

  ceq critical([eId | (energy(id,ff) @ t) kb ] aconf) = true 
   if equivZero(val(id,(energy(id,ff) @ t) kb)) .
  eq critical(aconf) = false [owise] .
  
  eq updateConf(bound(n) aconf) =
    if critical(aconf) then criticalConf aconf 
    else (if (n == 0) then goalConf  
         else bound(monus(n)) aconf fi) fi .

endm
)



