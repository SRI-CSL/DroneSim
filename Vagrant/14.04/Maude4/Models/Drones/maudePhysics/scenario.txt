mod SCENARIO is
  inc MODEL-TASKS .
  inc SOFT-AGENT-RULES .
  inc PRETTY .
  --- inc SOLVE-SCP{valuation2valpatrolonly} . 
  --- inc SOLVE-SCP{valuation2valpatrolenergy} . 
	--- inc SOLVE-SCP{valuation2valpatrolenergyconservative} . 

vars n n' t t0 m t1 : Nat .
vars i j x y z : Int .
vars sx sy sz dx dy dz v e c dt : FiniteFloat .
var dir : Dir .
vars wkb kb lkb ekb : KB .
var aconf : Conf .
var attrs : AttributeSet .
var id eid : Id .
var ids : IdSet .
var cl : Class .
var l home loc : Loc .
var a : Int .
var locs : LocList .

op bound : Nat -> ConfElt .

eq comDistance = 2 .

eq senXLow = 0.0 .
eq senYLow = 0.0 .
eq senZLow = 0.0 .

---- Grid size
eq gridStepX = 1.0 .
eq gridStepY = 1.0 .
eq gridStepZ = 1.0 .
 
eq chargeUnit = 5.0 .
eq maxCharge = 20.0 .

eq botDelay = 1 .
eq costMv(v) = 0.06 . --- consumes x percent battery per meter
eq periodicity = 60 .

eq vlift = 5.0 .
eq vland = 5.0 .

***(
Performed one experiment with dronekit copter at velocity 5m/s
and altitude 5m

Takeoff : 100% -> 97%
70m  : 96% -> 91%
100m : 91% -> 85%
100m : 84% -> 78%
100m : 77% -> 71%
100m : 70% -> 65%
70m : 64% -> 59%
Landing/Disarm : 58% -> 55%

)

**** ekb has current velocity vel
op mkBekb : Nat FiniteFloat FiniteFloat FiniteFloat FiniteFloat FiniteFloat 
             -> KB .
eq mkBekb(n,sx,sy,sz,v,e) = 
    (atloc(b(n),mkLoc(sx,sy,sz)) @ 0)
    class(b(n),Bot) (energy(b(n),e) @ 0) (vel(b(n),v) @ 0) (timeElapsed(0.0) @ 0) .

**** lkb has target velocity 
op mkBkb : Nat FiniteFloat FiniteFloat FiniteFloat FiniteFloat FiniteFloat FiniteFloat Int LocList -> KB .
eq mkBkb(n,sx,sy,sz,v,e,c,a,locs) = 
    mkBekb(n,sx,sy,sz,v,e) targetVelocity
    myAlt(b(n),a) (caution(b(n),c) @ 0)
    myHome(b(n),mkLoc(sx,sy,sz)) (targets(b(n),locs,nil) @ 0) 
    (visited(b(n),nil) @ 0) 
    (lastVisit(b(n),mkLoc(sx,sy,sz),0.0) @ 0)
    (mkCountVisits(n,locs)) (countLate(b(n),0) @ 0)
     clock(0) .

op mkCountVisits : Nat LocList -> KB .
eq mkCountVisits(n,loc ; locs) 
 = (countVisit(b(n),loc,0) @ 0) mkCountVisits(n,locs) .
eq mkCountVisits(n,nil) = none .

op mkB : Nat FiniteFloat FiniteFloat FiniteFloat FiniteFloat FiniteFloat FiniteFloat Int LocList -> Agent .
eq mkB(n,sx,sy,sz,v,e,c,a,locs) =
 [b(n) : Bot | lkb : mkBkb(n,sx,sy,sz,v,e,c,a,locs),
               ckb : none, evs : (tick @ 0)] .
 
ops mkE1 : Nat FiniteFloat FiniteFloat FiniteFloat FiniteFloat FiniteFloat -> Env .  **** bot env
ops mkE2 : Nat FiniteFloat FiniteFloat FiniteFloat FiniteFloat FiniteFloat -> Env .  **** bot env
eq mkE1(n,sx,sy,sz,v,e) = [eI | clock(0) mkBekb(n,sx,sy,sz,v,e)] .
eq mkE2(n,sx,sy,sz,v,e) = [eI | clock(0) (rand(0) @ 0) (wind(0.0,1.0,0.0) @ 0)
                                         mkBekb(n,sx,sy,sz,v,e) 
                                         mkBekb(s n,sx,sy,sz,v,e)] .

ops locs1 locs2 locs1p : -> LocList .
eq locs1 = mkLoc(50.0,10.0,5.0) ; mkLoc(10.0,30.0,5.0)
           ; mkLoc(-20.0,50.0,5.0) ; mkLoc(-40.0,5.0,5.0) .

eq locs2 = mkLoc(40.0,-10.0,10.0) ; mkLoc(-40.0,-40.0,10.0)
           ; mkLoc(-35.0,-5.0,10.0) ; mkLoc(10.0,-30.0,10.0) .

--- energy parameter is not yet useful
ops conf1 conf2 conf3 conf4 : -> Conf .
****           (n,sx,sy,sz,  v,  e,   c,  a,locs) 

eq conf1 = mkB(0,0.0,0.0,0.0,5.0,100.0,20.0,5,locs1)
           mkB(1,0.0,0.0,0.0,5.0,100.0,20.0,10,locs2)
           mkE2(0,0.0,0.0,0.0,5.0,100.0) . 

op asys1 : -> ASystem .
eq asys1 = { conf1 } .

--- eq windThresh = round(float(rand.25) / 2.0) .
eq windThresh = 0 .
eq stopSimulation = 75.0 .


ops asys asys2 : Nat -> ASystem .
eq asys(n) = { conf1 bound(n) } .

op getIds : ASystem -> IdSet .
eq getIds({ aconf }) = getIdsX(aconf, none)  .

op getIdsX : Conf IdSet -> IdSet .
eq getIdsX(aconf, ids) = ids [owise] .
eq getIdsX([id : cl | attrs] aconf, ids) = getIdsX(aconf, id ids) .

op upDateRand : ASystem Nat -> ASystem .
eq upDateRand({[ eI | ekb ] aconf}, n) =
              {[ eI | upDateRandKB(ekb,n)] aconf} .

op upDateRandKB  : KB Nat -> KB .
eq upDateRandKB(clock(t1) (rand(n') @ t) kb,n) = 
    clock(t1) (rand(n' + n) @ t1) kb .
eq upDateRandKB(kb,n) = kb [owise] .

****


endm
