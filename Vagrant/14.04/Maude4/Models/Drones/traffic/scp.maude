fth VALUATION is
  pr BOOL .
  inc SOFT-AGENTS .
  
  sort Grade . 
  op equivZero : Grade -> Bool .
  op _<_ : Grade  Grade -> Bool .
****  op _equiv_ : Grade x Grade -> Bool .  
 
  op val : Id KB Action  -> Grade .
***  op val : Id KB  -> Grade .

endfth


fmod SOLVE-SCP{Z :: VALUATION} is
   inc SOFT-AGENTS .

  vars v v0 v1 : Z$Grade .
  vars acts acts0 actset : ActSet .
  vars act1 act : Action .
  vars rks rks1 : RankSet{Z} .
  var id : Id .
  var kb : KB .
    
  sorts RankEle{Z} RankSet{Z} .
  op {_,_} : Z$Grade ActSet -> RankEle{Z} . 

  subsort RankEle{Z} < RankSet{Z} .
  op none : -> RankSet{Z} [ctor] .
  op __ : RankSet{Z} RankSet{Z} -> RankSet{Z} [ctor comm assoc id: none] .

  op getAct : RankSet{Z} -> ActSet .
  eq getAct({v,acts} rks) = acts getAct(rks) .
  eq getAct(none) = none .

  op updateRks : RankSet{Z} Action Z$Grade -> RankSet{Z} .
  ceq updateRks({v0,acts0} rks,act1,v1) = {v0,acts0} rks if v1 < v0 .
  ceq updateRks({v0,acts0} rks,act1,v1) = updateRks(rks,act1,v1) 
   if v0 < v1 .
  eq updateRks({v1,acts0} rks,act1,v1) = {v1,acts0 act1} rks .
  eq updateRks(rks,act1,v1) = 
      if equivZero(v1) then rks else {v1,act1} rks fi [owise] .
    
****  op solveSCP : Id KB ActSet -> ActSet .
  eq solveSCP(id,kb,acts) = solveSCP$(id,kb,acts,none) .

  op solveSCP$ : Id KB ActSet RankSet{Z} -> ActSet .
  eq solveSCP$(id,kb,none,rks) = getAct(rks) .
  ceq solveSCP$(id,kb,act actset,rks) = solveSCP$(id,kb,actset,rks1) 
   if v0 := val(id,kb,act)
   /\ rks1 := updateRks(rks,act,v0) .

endfm


**** Boolean Valuation Safe or Not

fmod BVAL is
  pr CONVERSION .

**** Grade is BVal  
  vars b1 b2 : BVal .
  sort BVal .

  op _<_ : BVal BVal -> Bool  .
  op equivZero : BVal -> Bool .

  ops bot top : -> BVal .
  eq  bot < top = true .
  eq x:BVal < y:BVal = false [owise] .

  eq equivZero(bot) = true .
  eq equivZero(top) = false .  

endfm

fmod TRIVAL is
  pr CONVERSION .

**** Grade is BVal  
  vars b1 b2 : TriVal .
  sort TriVal .

  op _<_ : TriVal TriVal -> Bool  .
  op equivZero : TriVal -> Bool .

  ops bot mid top : -> TriVal .
  eq  bot < top = true .
  eq  bot < mid = true .
  eq  mid < top = true .
  eq x:TriVal < y:TriVal = false [owise] .

  eq equivZero(bot) = true .
  eq equivZero(top) = false .  
  eq equivZero(mid) = false .  

endfm

**** safety valuation function for energy concern
**** defines eval
fmod VAL-ENERGY is
  inc SOFT-AGENTS .
  inc CONVERSION .
  inc BVAL .
  inc MODEL-KNOWLEDGE .

  var cl : Class .
  vars kb kb' : KB .
  vars id st : Id .
  vars cx cy cz e : FiniteFloat .
  vars loc locb : Loc .
  vars t0 t t1 x1 y1 z1 x0 y0 z0 : Nat .
  var act : Action .
  vars loc0 loc1 loc2 : Loc .
  var locs : LocSet .
  vars ni ni0 ni1 : Float .
  vars dir dir1 : Dir .
  var dummy : BVal .
 
  op val-energy : Id KB  -> BVal .
  eq val-energy(id,(energy(id,e) @ t0) kb) = 
   if e > getCaution(id,kb) then top else bot fi .

  op val-energy : Id KB Action  -> BVal .
  eq val-energy(id,(myHome(id,locb)) kb,goTo(id,loc1)) = 
   if locb == loc1 then top else  val-energy(id,doAct(id,kb,goTo(id,loc1))) fi .

  eq val-energy(id,kb,act) = bot [owise] .  **** shouldn't happen

endfm

fmod VAL-ENERGY-CONSERVATIVE is
  inc SOFT-AGENTS .
  inc CONVERSION .
  inc TRIVAL .
  inc MODEL-KNOWLEDGE .

  var cl : Class .
  vars kb kb' : KB .
  vars id st : Id .
  vars cx cy cz e : FiniteFloat .
  vars loc locb l0 lb : Loc .
  vars t0 t t1 x1 y1 z1 x0 y0 z0 : Nat .
  var act : Action .
  vars loc0 loc1 loc2 : Loc .
  var locs : LocSet .
  vars ni ni0 ni1 : Float .
  vars dir dir1 : Dir .
  var dummy : TriVal .
 

***  op caution : Id FiniteFloat -> Info .

  op towards : Loc Loc Loc -> Bool .
  eq towards(loc,loc1,locb) = 
               --- distance should reduce
               distance(locb,loc) > distance(loc1,locb) 
               --- and it should head home
               and angle(diff(loc,locb),diff(loc,loc1)) < pi / 4.0 .

  op val-energy : Id KB  -> TriVal .
  eq val-energy(id,(energy(id,e) @ t0) (atloc(id,loc) @ t) 
     (myHome(id,locb)) kb) = 
   if e >  getCaution(id,kb) then top else 
    (if e > cost2loc(loc,locb,getVel(id,kb)) then mid else bot fi) fi .

  op val-energy : Id KB Action  -> TriVal .
  ceq val-energy(id,kb,goTo(id,loc1)) = 
          val-energy(id,doAct(id,kb,goTo(id,loc1)))  
  if not (val-energy(id,doAct(id,kb,goTo(id,loc1))) == mid) .

  ceq val-energy(id,kb,goTo(id,loc1)) = 
    if towards(loc,loc1,locb) then mid else bot fi
   if val-energy(id,doAct(id,kb,goTo(id,loc1))) == mid  
   /\ (atloc(id,loc) @ t) (myHome(id,locb)) kb' := kb .

  eq val-energy(id,
         (energy(id,e) @ t0) (atloc(id,loc0) @ t) 
         (myHome(id,locb)) kb, charge(id)) =
         (if (loc0 == locb) 
          then (if (e >= maxCharge) then bot else top fi)
          else bot fi) .

  eq val-energy(id,kb,act) = bot [owise] .  **** shouldn't happen

endfm

fmod UVAL is
  pr CONVERSION .

***** Grade is Float
  vars u1 u2 : Float .
  

  op equivZero : Float -> Bool .
  eq equivZero(0.0) = true .
  eq equivZero(u1) = false [owise] .

endfm

fmod FFVAL is
  pr CONVERSION .

  sort FF .
  op {_,_} : FiniteFloat FiniteFloat -> FF .

***** Grade is Float
  vars u1 u2 : FF .
  vars fb fc fb0 fc0 : FiniteFloat .

*****!!! assume cost not 0.0
  op _<_ : FF FF -> Bool  .
  eq {fb,fc} < {fb0,fc0} 
   = (if (fb < fb0) or ((fb == fb0) and (fc > fc0))
     then true
     else (if (fb == fb0 and (fc < fc0))
           then false
           else (if (fb / fc ) < (fb0 / fc0 )
                 then true else false fi)
     fi) fi) .

  op equivZero : FF -> Bool .
  --- Anything with benefit zero is zero.
  eq equivZero({0.0,fc}) = true . 
  eq equivZero(u1) = false [owise] .

***(
  op _equiv_ : Float Float -> Bool [comm] .
  eq u1 equiv u2 = (u1 == u2) . 
  eq u1 <= u2 = (u1 < u2) or (u1 equiv u2) . 
)

endfm


fmod VAL-COVER is
  inc SOFT-AGENTS .
  inc CONVERSION .

  inc SOFT-AGENTS .
  inc CONVERSION .
  inc FFVAL .
  inc MODEL-KNOWLEDGE .

  vars kb kb' kb1 kb2 kb3 : KB .
  vars id st : Id .
  vars x y x1 y1 z1 x0 y0 z0 m n i : Nat .
  var act : Action .
  vars loc loc0 loc1 loc2 : Loc .
  var locs locs0 locs1 : LocList .
  vars dir dir1 : Dir .
  vars t t0 t1 : Time .
  vars st1 st2 v dt ff1 ff2 : FiniteFloat .
  var times : TimesList .
  vars ints1 ints2 : Intervals .
  
  op valueCS : Id KB -> FiniteFloat .
  op benefit : Id KB Action -> FiniteFloat .
  op cost : Id KB Action -> FiniteFloat .
  op val-visits : Id KB Action  -> FF .

  *** Notice that the greater the valueCS the worse
  ceq benefit(id,kb,goTo(id,loc)) = st1 - st2
   if kb1 := doActT(id,kb,goTo(id,loc))
   /\ st1 := valueCS(id,kb)
   /\ st2 := valueCS(id,kb1) .

  op sumInt : Intervals -> FiniteFloat .
  eq sumInt(< ff1, ff2 > ints1) = ff2 - ff1 + sumInt(ints1) .
  eq sumInt(none) = 0.0 .

  eq valueCS(id,(clock(t)) (notCovered(id,loc,ints1,ints2) @ t0) kb)
   = valueCS(id,(clock(t)) kb) + sumInt(ints1 ints2) .
  eq valueCS(id,kb) = 0.0 [owise] . *** not visited sites have 

  ceq cost(id,kb,goTo(id,loc)) = cost2locT(loc0,loc,v,time2Loc(loc0,loc,v)) 
   if v := getVel(id,kb) 
   /\ loc0 := getLoc(id,kb) .

  eq val-visits(id,kb,act) 
   = {benefit(id,kb,act),cost(id,kb,act)} .

  eq equivZero({ff1,ff2}) = ff1 < 0.0 .
endfm

fmod VAL-COVER-ENERGY is
  inc VAL-COVER .
  inc VAL-ENERGY .

  var id : Id . 
  var kb : KB . 
  var act : Action .
  vars b1 b2 : BVal .
  vars u1 u2 : FF .
  
  sort TFFVal .
  op {_,_} : BVal FF -> TFFVal .

  op val : Id KB -> TFFVal .
  op val : Id KB Action -> TFFVal .
  eq val(id,kb) = {val-energy(id,kb),{1.0,1.0}} .
  eq val(id,kb,act) = {val-energy(id,kb,act),val-visits(id,kb,act)} .

  op _<_ : TFFVal TFFVal -> Bool .
  op equivZero : TFFVal -> Bool .

  eq {b1,u1} < {b2,u2} = (b1 < b2) or (b1 == b2 and u1 < u2) .
  eq equivZero({b1,u1}) = (equivZero(b1)) or (equivZero(u1)) .
endfm

view  valuation2valcover from VALUATION to VAL-COVER-ENERGY is
  sort Grade to TFFVal .
endv 

