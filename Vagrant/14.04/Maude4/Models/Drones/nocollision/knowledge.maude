fmod MODEL-KNOWLEDGE is
  inc SOFT-AGENTS .
	inc CONVERSION .


  vars t t0 t1 t2 : Time .
  vars alt x y x1 y1 x0 y0 z0 z1 z thr x2 y2 z2 
  x3 y3 z3 x4 y4 z4 x5 y5 z5  x6 y6 z6 : Int .
  vars id id0 id1 : Id .
	var cl : Class .
  vars l l0 l1 l2 l3 l4 loc locTL locTR loc0 : Loc .
  vars ekb ekb0 ekb1 kb  lkb kb1 lkb0 kb3 statObjs kb2 :  KB .
  var dir dir0 dir1 : Dir .
  vars e e0 e1 ff0 ff1 ffx ffy ffz ff ffx0 ffx1 ffy0 ffy1 ffz0 ffz1 v sx sy sz norm1 norm2 dt dt0 dt1 fdx fdy fdz ffn ffxnu1 ffxnu2 ffynu1 ffynu2 ff2 a b c d dxc dyc dxl dyl cross
  safety xsafety prevention 
  ffx2 ffy2 ffz2 ffx3 ffy3 ffz3 : FiniteFloat .
  vars locs locs0 locs1 locs2 locs3 : LocList .
  var act act0 act1 pact : Action .
  var acts : ActSet .
  vars n n0 n1 r j : Nat .
	var times : TimesList .
  var mInv : [Float] .
  vars b1 b2 : Bool .

  op b : Nat -> Id .
  op st : Nat -> Id .
  op eI : -> Id .
*** parameters
  --- ops gridX gridY gridZ : -> Nat .
  --- for shifting coordinates 0,0
  ops senXLow senYLow senZLow : -> FiniteFloat . 
  ops gridStepX gridStepY gridStepZ : -> FiniteFloat .
  op edgeX : -> Int .

  --- eq gridStepX = floor((senXHigh - senXLow) / float(gridX)) . 
  --- eq gridStepY = floor((senYHigh - senYLow) / float(gridY)) . 
  --- eq gridStepZ = floor((senZHigh - senZLow) / float(gridZ)) . 

  op comDistance : -> Nat .
  op periodicity : -> Nat .

  op chargeUnit : -> FiniteFloat .
  op maxCharge : -> FiniteFloat .      --- stop charging when full
 
  op botDelay : -> Nat .
  op costMv : FiniteFloat -> FiniteFloat .

***** done up/dn velocities
  op vlift : -> FiniteFloat .
  op vland : -> FiniteFloat .

*** class
  op Bot : -> Class .
  op Station : -> Class .

*** grid-location
  sorts GridLoc SenLoc .
  op pt : Int Int Int -> Loc .

  op mkLoc : FiniteFloat FiniteFloat FiniteFloat -> Loc .
  eq mkLoc(ffx,ffy,ffz) = pt(rat(floor((ffx - senXLow) / gridStepX)), 
                          rat(floor((ffy - senYLow) / gridStepY)),
                          rat(floor((ffz - senZLow) / gridStepZ))) .

op equiv : Loc Loc -> Bool .
  eq equiv(l0,l0) = true .
  eq equiv(l0,l1) = false [owise] .

  sort LocList .
  subsort Loc < LocList .
  op nil : -> LocList [ctor] .
  op _;_ : LocList LocList -> LocList [ctor assoc id: nil] .

  op first : LocList ~> Loc .
  op rest : LocList ~> LocList .
  eq first(loc ; locs) = loc .
  eq rest(loc ; locs) = locs .
  op len : LocList -> Nat .
  eq len((nil).LocList) = 0 .
  eq len(loc ; locs) = s (len(locs)) .

 op diff : Loc Loc -> Loc .
  eq diff(pt(x0,y0,z0),pt(x1,y1,z1)) 
   = pt((x1 - x0),(y1 - y0),(z1 - z0)) .

  --- Here we are using locs as vectors. So do not use (0,0,0).
  op angle : Loc Loc -> FiniteFloat .
  ceq angle(pt(x0,y0,z0),pt(x1,y1,z1)) 
   = acos(ffx0 * ffx1 + ffy0 * ffy1 + ffz0 * ffz1) 
   if norm1 := sqrt(float(x0 ^ 2) + float(y0 ^ 2) + float(z0 ^ 2)) 
   /\ norm2 := sqrt(float(x1 ^ 2) + float(y1 ^ 2) + float(z1 ^ 2)) 
   /\ ffx0 := float(x0) / norm1 
   /\ ffy0 := float(y0) / norm1 
   /\ ffz0 := float(z0) / norm1 
   /\ ffx1 := float(x1) / norm2 
   /\ ffy1 := float(y1) / norm2 
   /\ ffz1 := float(z1) / norm2 .
     
  op wind : FiniteFloat FiniteFloat FiniteFloat Nat -> Info .
  op getWind : KB -> KB .
  eq getWind((wind(ffx,ffy,ffz,thr) @ t) kb ) = (wind(ffx,ffy,ffz,thr) @ t) .
  eq getWind(kb) = none [owise] .

  op getObstacles : Id KB -> KB .
  ceq getObstacles(id,it:KItem kb) = it:KItem getObstacles(id,kb)
   if isObstacle(id,it:KItem) .
  eq getObstacles(id,kb) = none [owise] .

  op isObstacle : Id KItem -> Bool .
  eq isObstacle(id,movObj(id,loc,ffx,ffy,ffz) @ t) = true .
  eq isObstacle(id,statObj(id,locTL,locTR,locs,dir) @ t) = true .
  eq isObstacle(id,it:KItem) = false [owise] .

  *** Knowledge fact specifying that some drone 
  *** has reached energy zero during flight
  op crashed : Id Loc FiniteFloat -> Info .
  eq hasId(id,crashed(id,loc,ff) @ t) = true .
  *** Knowledge fact specifying that some drone
  *** landed far from home
  op landFarFromHome : Id Loc FiniteFloat -> Info .
  eq hasId(id,landFarFromHome(id,loc,ff) @ t) = true .

  *** Moving object detected with velocity ffx, ffy, ffz at location loc
  op movObj : Id Loc FiniteFloat FiniteFloat FiniteFloat -> Info .
  eq hasId(id,movObj(id,loc,ffx,ffy,ffz) @ t) = true .

  *** Static object on ground represented as a rectangle on position locTL, locTR
  op statObj : Id Loc Loc LocList Dir -> Info .
  eq hasId(id,statObj(id,locTL,locTR,locs,dir) @ t) = true .  

  *** parameters: safety -- min distance to moving object
  ***             delta -- max time to collision  
  op safetyMv : Id FiniteFloat FiniteFloat -> PKItem .
  *** parameter: safety -- min distance to statical object
  op safetyStat : Id FiniteFloat FiniteFloat -> PKItem .

  op pending : Id Action -> Info .
  eq hasId(id,pending(id,act) @ t) = true .

  op getLoc : Action -> Loc .
  eq getLoc(goTo(id,loc)) = loc .
  eq getLoc(goToW(id,loc,dt)) = loc .
  eq getLoc(act) = nil [owise] . *** Make sure it is always a goto

  op targets : Id LocList LocList -> Info .
  eq hasId(id,targets(id,locs,locs1) @ t) = true .

  op isTarget : Loc KB -> Bool .
  eq isTarget(loc,(targets(id,locs0 ; loc ; locs,locs1) @ t) kb) = true .
  eq isTarget(loc,(targets(id,locs,locs0 ; loc ; locs1) @ t) kb) = true .
  eq isTarget(loc,kb) = false [owise] .

  op lastVisit : Id Loc FiniteFloat -> Info .
  eq hasId(id,lastVisit(id,loc,dt) @ t) = true .

  op getTimeVisit : Id Loc KB -> FiniteFloat .
  eq getTimeVisit(id,loc,(lastVisit(id,loc,dt) @ t) kb) = dt .
  eq getTimeVisit(id,loc,kb) = 0.0 [owise] .

  op countVisit : Id Loc Nat -> Info .
  eq hasId(id,countVisit(id,loc,n) @ t) = true .

  op countLate : Id Nat -> Info .
  eq hasId(id,countLate(id,n) @ t) = true .

  op visited : Id LocList -> Info .
  eq hasId(id,visited(id,locs) @ t) = true .

  op myHome : Id Loc -> PKItem .
  eq hasId(id,myHome(id,loc)) = true .

  op myDir : Id FiniteFloat FiniteFloat FiniteFloat -> Info .
  eq hasId(id,myDir(id,ffx,ffy,ffz) @ t0 ) = true .

  op myAlt : Id Int -> PKItem .
  eq hasId(id,myAlt(id,alt)) = true .

  op energy : Id FiniteFloat -> Info [ctor] .
  eq hasId(id,energy(id,e) @ t) = true .

  op getEnergy : Id KB -> FiniteFloat .
  eq getEnergy(id, (energy(id,e) @ t) lkb ) = e .
  eq getEnergy(id,lkb) = 0.0 [owise] .

  op caution : Id FiniteFloat -> Info [ctor] .
  eq hasId(id,caution(id,e) @ t) = true .
	
  op getCaution : Id KB -> FiniteFloat .
  eq getCaution(id, (caution(id,e) @ t) lkb ) = e .
  eq getCaution(id,lkb ) = 1.0 [owise] .

  op timeElapsed : FiniteFloat -> Info .
  op getTimeElapsed : KB -> KB .
  eq getTimeElapsed((timeElapsed(dt) @ t) kb) = timeElapsed(dt) @ t .
  eq getTimeElapsed(kb) = none [owise] .

  op rand : Nat -> Info .
  op getRand : Id KB -> KB .
  eq getRand(b(j),(rand(r) @ t) (clock(t1)) kb) = rand(r + t1 * (s j)) @ t1 .
  eq getRand(id,kb) = none [owise] .

  **** This is the target velocity is the absolute velocity
  op targetVel : Id FiniteFloat -> Info .  
  eq hasId(id,targetVel(id,ff) @ t) = true .

  op getVel : Id KB -> FiniteFloat .
  eq getVel(id, (targetVel(id,v) @ t) lkb ) = v .
  eq getVel(id,lkb) = 0.0 [owise] .

  op vel : Id FiniteFloat -> Info .  **** myVel is the absolute velocity -- i.e. speed
  eq hasId(id,vel(id,ff) @ t) = true .

  op getCurVel : Id KB -> FiniteFloat .
  eq getCurVel(id, (vel(id,v) @ t) lkb ) = v .
  eq getCurVel(id,lkb) = 0.0 [owise] .

******** bot  actions
  op continue : Id -> Action .
  op takeOff : Id Int -> Action .
  op land : Id -> Action .
  op stop : Id -> Action .
  op land : Id Nat -> Action .
--- We will need to probably add velocity to the goTo action
  op goTo : Id Loc -> Action .
  op goToW : Id Loc FiniteFloat -> Action .
  op goToW : Id FiniteFloat FiniteFloat FiniteFloat FiniteFloat FiniteFloat FiniteFloat FiniteFloat -> Action .
  *** the following two are deprecated!
  op mv : Id Dir FiniteFloat -> Action .
  op charge : Id -> Action .
  
op inBox : Id Loc Loc FiniteFloat Loc -> Bool .
ceq inBox(id,pt(x1,y1,z1),pt(x2,y2,z2),safety,pt(x0,y0,z0))
    = (if d >= safety then false 
      else 
        betweenPoints(ffx3,ffy3,pt(x1,y1,z1),pt(x2,y2,z2))
        or 
        distanceFF(pt(x1,y1,0),pt(round(ffx3),round(ffy3),0)) < safety 
        or 
        distanceFF(pt(x2,y2,0),pt(round(ffx3),round(ffy3),0)) < safety
      fi)
   if ffx0 := float(x0)
   /\ ffx1 := float(x1)
   /\ ffx2 := float(x2)
   /\ ffy0 := float(y0)
   /\ ffy1 := float(y1)
   /\ ffy2 := float(y2)
   /\ a := if (ffx2 - ffx1) == 0.0 then 1.0 
                     else  (ffy2 - ffy1) / (ffx2 - ffx1) fi 
   /\ b := if (ffx2 - ffx1) == 0.0 then 0.0  
                         else - 1.0 fi
   /\ c := if (ffx2 - ffx1) == 0.0 then - ffx1  
             else (- (a * ffx1)) + ffy1 fi 
   /\ ff := a ^ 2.0 + b ^ 2.0
   --- /\ d := abs((ffy2 - ffy1) * ffx0 - (ffx2 - ffx1) * ffx0 + ffx2 * ffy1 - ffy2 * ffy1) / sqrt((ffy2 - ffy1) ^ 2.0 + (ffx2 - ffx1) ^ 2.0)
   /\ d := abs(a * ffx0 + b * ffy0 + c) / sqrt(ff) 
   /\ ffx3 := (b * (b * ffx0 - a * ffy0) - a * c) / ff 
   /\ ffy3 := (a * (- b * ffx0 + a * ffy0) - b * c) / ff 
   [print ffx3 " " ffy3 " " d] .

*** http://stackoverflow.com/questions/11907947/how-to-check-if-a-point-lies-on-a-line-between-2-other-points/11912171
  op betweenPoints : FiniteFloat FiniteFloat Loc Loc -> Bool .
  ceq betweenPoints(ffx0,ffy0,pt(x1,y1,z1),pt(x2,y2,z2)) = 
     (if not (cross == 0.0) then false 
     else 
      (if abs(dxl) > abs(dyl) then 
        (if dxl > 0.0 then ffx1 <= ffx0 and ffx0 <= ffx2 
                    else ffx2 <= ffx0 and ffx0 <= ffx1
         fi)
      else
        (if dyl > 0.0 then ffy1 <= ffy0 and ffy0 <= ffy2 
                    else ffy2 <= ffy0 and ffy0 <= ffy1
         fi)
      fi)
     fi) 
   if ffx1 := float(x1) 
   /\ ffx2 := float(x2) 
   /\ ffy1 := float(y1) 
   /\ ffy2 := float(y2)
   /\ dxc := ffx0 - ffx1
   /\ dyc := ffy0 - ffy1
   /\ dxl := ffx2 - ffx1
   /\ dyl := ffy2 - ffy1
   /\ cross := dxc * dyl - dyc * dxl  .

  op distanceFF : Loc Loc -> FiniteFloat .
  eq distanceFF(pt(x0,y0,z0),pt(x1,y1,z1)) = 
    float((abs(x0 - x1))) * gridStepX + float(abs(y0 - y1)) * gridStepY + float(abs(z0 - z1)) * gridStepZ .

  eq distance(pt(x0,y0,z0),pt(x1,y1,z1)) = 
    abs(x0 - x1) + abs(y0 - y1) + abs(z0 - z1) .

  op getNormVec : Loc Loc -> Dir .
  ceq getNormVec(pt(x0,y0,z0),pt(x1,y1,z1)) = dir(fdx / ffn, fdy / ffn, fdz / ffn)
   if fdx := float(x1 - x0) / gridStepX
   /\ fdy := float(y1 - y0) / gridStepY
   /\ fdz := float(z1 - z0) / gridStepZ
   /\ ffn := sqrt(fdx ^ 2.0 + fdy ^ 2.0 + fdz ^ 2.0) .

  op timesDir : FiniteFloat Dir -> Dir .
  eq timesDir(ff,dir(ffx0,ffy0,ffz0)) = dir(ff * ffx0,ff * ffy0,ff * ffz0) .

  --- location occupied if there is a bot at the location
   op occupied : Loc KB -> Bool .
  eq occupied(l0,(atloc(id,l0) @ t) class(id,Bot) ekb) = true .
  eq occupied(l0, ekb) = false [owise] .

  --- in contact if distance is less than or equal to comDistance
  eq inContact(id0,id1,ekb) 
   = distance(getLoc(id0,ekb),getLoc(id1,ekb)) <= comDistance .

  sort Dir . 
  ops E W N S : -> Dir .  **** east (right) west (left) north south
  --- dir(x,y,z) where -1 <= x,y,z <= 1.0
  op dir : FiniteFloat FiniteFloat FiniteFloat -> Dir .
  eq E = dir(1.0,0.0,0.0) .
  eq W = dir(-1.0,0.0,0.0) .
  eq N = dir(0.0,1.0,0.0) . 
  eq S = dir(0.0,-1.0,0.0) . 

  op reverseDir : Dir -> Dir .
  eq reverseDir(dir) = if dir == E then W 
                       else (if dir == W then E 
                         else (if dir == N then S 
                               else (if dir == S then N else dir fi)
                               fi)
                         fi)
                       fi .
**** model of expected result of move actions
  op round : FiniteFloat -> Int .
  ceq round(sx) =
    (if (sx >= 0.0)
      then (if r:Rat < 1/2 then floor(rat(sx)) else ceiling(rat(sx)) fi)
      else (if r:Rat < 1/2 then ceiling(rat(sx)) else floor(rat(sx)) fi)
    fi)
    if r:Rat := rat(sx) - floor(rat(sx)) .

  op doMv : Loc Dir FiniteFloat -> Loc .
  eq doMv(pt(x0,y0,z0),dir(ffx0,ffy0,ffz0),v) 
   = pt(x0 + round(ffx0 * v / gridStepX),
        y0 + round(ffy0 * v / gridStepY),
        z0 + round(ffz0 * v / gridStepZ)) .

  eq doMv(l0,dir,v) = l0 [owise] .


*** partial order
  eq atloc(id,l0) @ t0 << atloc(id,l1) @ t1 = t0 < t1 .
  eq (clock(t0)) << (clock(t1)) = t0 < t1 .
  eq (energy(id,e0) @ t0) << (energy(id,e1) @ t1) =  t0 < t1 .
  eq (caution(id,e0) @ t0) << (caution(id,e1) @ t1) =  t0 < t1 .
  eq vel(id,ff0) @ t0 << vel(id,ff1) @ t1 = t0 < t1 .
  eq targetVel(id,ff0) @ t0 << targetVel(id,ff1) @ t1 = t0 < t1 .
  eq rand(r1:Nat) @ t0 << rand(r2:Nat) @ t1 = t0 < t1 .
  eq targets(id,locs0,locs1) @ t0 << targets(id,locs2,locs3) @ t1 = t0 < t1 .
  --- eq visited(id,locs0) @ t0 << visited(id,locs1) @ t1 = t0 < t1 .
  eq lastVisit(id,l0,dt0) @ t0 << lastVisit(id,l0,dt1) @ t1 = t0 < t1 .
  eq pending(id, act0) @ t0 << pending(id, act1) @ t1 = t0 < t1 .
  eq timeElapsed(dt0) @ t0 << timeElapsed(dt1) @ t1 = t0 < t1 .
  eq landFarFromHome(id,l0,ff0) @ t0 << landFarFromHome(id,l1,ff) @ t1 = t0 < t1 . *** it does not matter which one we keep.

  op incCountVisit : Id Loc Time KB -> KB .
  eq incCountVisit(id,loc,t1,(countVisit(id,loc,n) @ t) kb) = (countVisit(id,loc,s n) @ t1) kb .
  eq incCountVisit(id,loc,t1,kb) = kb [owise] .

  op incLateVisit : FiniteFloat FiniteFloat Time KB -> KB .
  eq incLateVisit(dt0,dt1,t1,(countLate(id,n) @ t) kb) = 
   if dt1 - dt0 > float(periodicity) then (countLate(id,s n) @ t1) kb
   else (countLate(id,n) @ t) kb fi .
  eq incLateVisit(dt0,dt1,t1,kb) = kb [owise] .

  op close : Loc Loc -> Bool .
 
********* helpers
  op myActs : Class Id KB -> ActSet .
  eq myActs(cl,id,lkb) = goTos(cl,id,lkb) .

  op goTos : Class Id KB -> ActSet .
  op goTos$ : Class Id LocList -> ActSet .
  eq goTos(cl,id,(targets(id,locs,locs1) @ t) kb) = 
   goTos$(cl,id, locs ; locs1) .
  eq goTos$(cl,id,loc ; locs) = goTo(id,loc) goTos$(cl,id,locs) .
  eq goTos$(cl,id,nil) = none .

*** Compute (x0 + cos(theta - 30) * |V|, y0 + cos(theta - 30) * |V|)

op myActsA : Class Id LocList KB -> ActSet .
op myActsSafe : Class Id LocList KB -> ActSet .
op myActsCautious : Id KB KB -> ActSet .
op mkGoToW : Id LocList FiniteFloat -> ActSet .

ceq myActsA(cl,id,locs, (targets(id,locs0, locs1) @ t) kb) =
  (if statObjs == none then 
       myActsSafe(cl,id,locsdiff((locs0 ; locs1), locs),kb)
       else 
       myActsCautious(id,kb,statObjs)            
  fi) 
if statObjs := inPrevention(id,kb,none) .

ceq myActsCautious(id,kb (targetVel(id,v) @ t0) 
        (safetyStat(id,safety,prevention)),statObjs) 
 = mkGoToW(id,locs3,v)
 if locs := getAllSafePoints(id,kb)
 /\ pt(x0,y0,z0) := getLoc(id,kb)
 /\ locs1 := getClosest(2,pt(x0,y0,z0),locs)
 /\ locs2 := getExitPoints(id,pt(x0,y0,z0),v,statObjs)
 /\ l2 := pt(x0,y0,z0 + round(vlift))
 /\ locs3 := notInAnySafetyBox(id,kb,safety,l2 ; locs1 ; locs2) .

 op getExitPoints : Id Loc FiniteFloat KB -> LocList .
 ceq getExitPoints(id,pt(x0,y0,z0),v,
            (statObj(id,locTL,locTR,locs,dir(ffx1,ffy1,ffz1)) @ t) kb) =
     l3 ; getExitPoints(id,pt(x0,y0,z0),v,kb)
  if l1 := pt(x0 + round(ffx1 * v),y0 + round(ffy1 * v),z0 + round(ffz1 * v))
  /\ l2 := pt(x0 - round(ffx1 * v),y0 - round(ffy1 * v),z0 - round(ffz1 * v))
  /\ ff1 := distanceFF(locTL,l1)
  /\ ff2 := distanceFF(locTL,l2)
  /\ l3 := if ff1 > ff2 then l1 else l2 fi .

 op notInAnySafetyBox : Id KB FiniteFloat LocList -> LocList .
 ceq notInAnySafetyBox(id,
    (statObj(id,locTL,locTR,locs1,dir) @ t) kb,safety,l0 ; locs) = 
    notInAnySafetyBox(id,
     (statObj(id,locTL,locTR,locs1,dir) @ t) kb,safety,locs)
  if inBox(id,locTL,locTR,safety,l0) .

 eq notInAnySafetyBox(id,kb,safety,l0 ; locs) = 
   l0 ; notInAnySafetyBox(id,kb,safety,locs) [owise] .
    
 eq notInAnySafetyBox(id,kb,safety,nil) = nil .  
  
 ceq myActsSafe(cl,id,loc0 ; locs, kb) = 
      (goToW(id,pt(x1,y1,z1),v)) myActsSafe(cl,id,locs,kb)
  if (myAlt(id,alt)) (atloc(id,loc) @ t1) (targetVel(id,v) @ t2) kb1 := kb
  /\ pt(x2,y2,z2) := loc0
  /\ pt(x0,y0,z0) := loc 
  /\ dir(ffx1,ffy1,ffz1) := getNormVec(loc,pt(x2,y2,alt))
  /\ pt(x1,y1,z1) := pt(round(ffx1 * v) + x0,
                        round(ffy1 * v) + y0,
                        round(ffz1 * v) + z0) . 

eq myActsSafe(cl,id,nil,kb) = none .

op inPrevention : Id KB KB -> KB .
ceq inPrevention(id,kb (atloc(id,l0) @ t0) 
                (statObj(id,l1,l2,locs,dir) @ t)
                (safetyStat(id,safety,prevention)),kb1) = 
    inPrevention(id,kb (atloc(id,l0) @ t0) 
                (safetyStat(id,safety,prevention)),kb2 kb1) 
 if kb2 := if inBox(id,l1,l2,prevention,l0) then 
           (statObj(id,l1,l2,locs,dir) @ t) else none fi .

eq inPrevention(id,kb,kb1) = kb1 [owise] .



op getClosest : Nat Loc LocList -> LocList .
op getClosest$ : Loc LocList -> LocList .
op getClosest$$ : Loc FiniteFloat Loc LocList LocList -> LocList .

eq getClosest(0,l0,locs) = nil .
eq getClosest(n,l0,nil) = nil .
ceq getClosest(s n,l0,locs) = l1 ; getClosest(n,l0,locs1)
 if l1 ; locs1 := getClosest$(l0,locs) .
eq getClosest$(l0,l1 ; locs) = getClosest$$(l0,distanceFF(l0,l1),l1,locs,nil) .
eq getClosest$$(l0,ff,l1,l2 ; locs,locs1) 
  = if distanceFF(l0,l2) < ff then 
     getClosest$$(l0,distanceFF(l0,l2),l2,locs,l1 ; locs1)
    else 
      getClosest$$(l0,ff,l1,locs,l2 ; locs1) 
    fi .
eq getClosest$$(l0,ff,l1,nil,locs1) = l1 ; locs1 .

op getAllSafePoints : Id KB -> LocList .
eq getAllSafePoints(id,(statObj(id,l1,l2,locs1,dir) @ t) kb) =
  locs1 ; getAllSafePoints(id,kb) .
eq getAllSafePoints(id,kb) = nil [owise] .

op getSafePoints : Loc Loc FiniteFloat -> LocList .
ceq getSafePoints(pt(x1,y1,z1),pt(x2,y2,z2), safety) = l1 ; l2 ; l3 ; l4 
 if xsafety := safety + 1.0
 /\ dir(ffx0,ffy0,ffz0) := getNormVec(pt(x1,y1,z1),pt(x2,y2,z2))
 /\ pt(x3,y3,z3) := pt(x2 + round(ffx0 * xsafety),y2 + round(ffy0 * xsafety),z2)
 /\ pt(x4,y4,z4) := pt(x1 - round(ffx0 * xsafety),y1 - round(ffy0 * xsafety), 
   z2)
 /\ mInv := - float(x2 - x1) / float(y2 - y1) 
 /\ pt(x5,y5,z5) := if (y2 == y1) then pt(x3,0,z2) 
                    else (if (x2 == x1) then pt(0,y3,z2)
                         else pt(round(mInv) * y3 + x3, 0, z2) 
                         fi) fi  
 /\ dir(ffx1,ffy1,ffz1) := getNormVec(pt(x3,y3,z3),pt(x5,y5,z5))
 /\ l1 := pt(x3 + round(ffx1 * xsafety),y3 + round(ffy1 * xsafety),z2) 
 /\ l2 := pt(x3 - round(ffx1 * xsafety),y3 - round(ffy1 * xsafety),z2)
 /\ pt(x6,y6,z6) := if (y2 == y1) then pt(x4,0,z2) 
                    else (if (x2 == x1) then pt(0,y4,z2)
                         else pt(round(mInv) * y4 + x4, 0, z2) 
                         fi) fi  
 /\ dir(ffx2,ffy2,ffz2) := getNormVec(pt(x4,y4,z4),pt(x6,y6,z6))
 /\ l3 := pt(x4 + round(ffx2 * xsafety),y4 + round(ffy2 * xsafety),z2) 
 /\ l4 := pt(x4 - round(ffx2 * xsafety),y4 - round(ffy2 * xsafety),z2) .

op _+_ : Loc Loc -> Loc [assoc comm] .
op _-_ : Loc Loc -> Loc [assoc comm] .
eq (pt(x1,y1,z1) + pt(x2,y2,z2)) = pt(x1 + x2,y1 + y2,z1 + z2) .
eq (pt(x1,y1,z1) - pt(x2,y2,z2)) = pt(x1 - x2,y1 - y2,z1 - z2) .

op locsdiff : LocList LocList -> LocList .
eq locsdiff(locs0 ; loc ; locs1,loc ; locs) = 
     locsdiff(locs0 ; locs1, locs) .
eq locsdiff(locs1, loc ; locs) =  locsdiff(locs1, locs) [owise] .
eq locsdiff(locs1, nil)  = locs1 .

  op getLastVisits : Class Id KB -> KB .
  eq getLastVisits(cl,id,(lastVisit(id,loc,dt) @ t) kb)
   = (lastVisit(id,loc,dt) @ t) getLastVisits(cl,id,kb) .
  eq getLastVisits(cl,id, kb) = none [owise] .

**** at the same grid as a station and not fully charged 
  op canCharge : Class Id KB -> Bool .
  ceq canCharge(Bot,id,lkb) = true
  if (atloc(id,l0) @ t0) class(id,Bot)
     (atloc(id1,l0) @ t1) class(id1,Station)
     (energy(id,e) @ t2) lkb0 := lkb
  /\ e < maxCharge .

  eq canCharge(Bot,id,lkb) = false [owise] .

  op myMvs : Class Id KB -> ActSet .

	ceq myMvs(Bot,id, lkb) =
    ((if occupied(l0,lkb) then none else mv(id,E,v) fi)
     (if occupied(l1,lkb) then none else mv(id,W,v) fi)		
     (if occupied(l2,lkb) then none else mv(id,S,v) fi)				
     (if occupied(l3,lkb) then none else mv(id,N,v) fi)	)
   if l := getLoc(id,lkb)
   /\ v := getVel(id,lkb)
	 /\ l0 := doMv(l,E,v)
	 /\ l1 := doMv(l,W,v)
	 /\ l2 := doMv(l,S,v)
	 /\ l3 := doMv(l,N,v) .

	eq myMvs(cl,id,lkb) = none [owise] .

	op doAct : Id KB Action -> KB .
	
  ceq doAct(id,kb,charge(id)) = kb1
   if e0 := getEnergy(id,kb) + chargeUnit
   /\ e := min(e0, maxCharge)
   /\ t := getTime(kb)
   /\ kb1 := addK(kb, clock(s t) (energy(id,e) @ s t)) .

  ceq doAct(id,kb,goTo(id,loc)) = kb1
   if t0 := getTime(kb)
   /\ l0 := getLoc(id,kb)
   /\ v := getVel(id,kb)
   /\ e0 := getEnergy(id,kb) - cost2loc(l0,loc,v) 
   /\ ff := distanceFF(l0,loc)
   /\ timeElapsed(dt0) @ t2 := getTimeElapsed(kb)
   --- Once we are able to link the model's timestamp with SITL's 
   --- This is a very rough estimate of arrival time
   /\ dt1 := (ff / v) + dt0
   /\ t1 := s t0
   /\ kb1 := addK((clock(t1)) (atloc(id,loc) @ t1) 
                  (energy(id,e0) @ t1),incCountVisit(id,loc,t1,kb)) .

  ceq doAct(id,kb,goToW(id,loc,v)) = kb1
   if t0 := getTime(kb)
   /\ l0 := getLoc(id,kb)
   /\ e0 := getEnergy(id,kb) - cost2loc(l0,loc,v) 
   /\ ff := distanceFF(l0,loc)
   /\ timeElapsed(dt0) @ t2 := getTimeElapsed(kb)
   --- Once we are able to link the model's timestamp with SITL's 
   --- This is a very rough estimate of arrival time
   /\ dt1 := (ff / v) + dt0
   /\ t1 := s t0
   /\ kb1 := addK((clock(t1)) (atloc(id,loc) @ t1) 
                  (energy(id,e0) @ t1),incCountVisit(id,loc,t1,kb)) .


  op cost2loc : Loc Loc FiniteFloat -> FiniteFloat .
  eq cost2loc(l0,l1,v) = (distanceFF(l0,l1) / v) * costMv(v) .

  op getLKB : Id Conf -> KB .
  eq getLKB(id:Id,[id:Id : cl:Class | lkb : kb:KB, attrs:AttributeSet] pc:Conf) = kb:KB .
	

  op getPending : Id KB -> ActSet . **** 0 or 1
  eq getPending(id, kb (pending(id,pact) @ t)) = pact .
  eq getPending(id, kb) = none [owise] .
  
  op pickOne : ActSet -> Action .
  eq pickOne(act acts) = act .
  
  op isGoTo : Action Loc -> Bool .
  eq isGoTo(goToW(id,loc,v), loc) = true .
  eq isGoTo(goTo(id,loc), loc) = true .
  eq isGoTo(act,loc) = false [owise] .
  
  op isStop : Action -> Bool .
  eq isStop(stop(id)) = true .
  eq isStop(act) = false [owise] .

*********16dec06 clt new stuff
***** using NAT-LIST causes ambiguity -- Maude thinks (n - m) could be
***** the list (n -m)   which is silly becuase -m is not a Nat, but ....

sort TimesList .
subsort Nat < TimesList .
op nil : -> TimesList .
op _;_ : TimesList TimesList -> TimesList [ctor assoc id: nil] .

op len : TimesList -> Nat .
eq len((nil).TimesList) = 0 .
eq len( n ; times) = s (len(times)) .

op first : TimesList ~> Nat .
eq first( n ; times) = n .
op rest : TimesList -> TimesList .
eq rest( n ; times) = times .
eq rest(times) = nil [owise] .

**** track visitTimes, the rest can be computed
  op visitTimes : Id Loc TimesList -> Info .  --- list initially nil
  eq hasId(id,visitTimes(id,loc,times) @ t) = true .

*** managed by update function, no need for partial order
*** var times : TimesList .

  op incVisitTimes : Id Loc Time KB -> KB .
  eq incVisitTimes(id,loc,t1,(visitTimes(id,loc,times) @ t) kb) = 
	                (visitTimes(id,loc,(times ; t1)) @ t1) kb .
  eq incVisitTimes(id,loc,t1,kb) = kb [owise] .
	

  op distanceDir : Loc Loc -> FiniteFloat .
  ceq distanceDir(pt(x0,y0,z0),pt(x1,y1,z1)) = ffn
   if fdx := float(x1 - x0) / gridStepX
   /\ fdy := float(y1 - y0) / gridStepY
   /\ fdz := float(z1 - z0) / gridStepZ
   /\ ffn := sqrt(fdx ^ 2.0 + fdy ^ 2.0 + fdz ^ 2.0) .
  
****** using visit times

	op doActT : Id KB Action -> KB .
	
  ceq doActT(id,kb,charge(id)) = kb1
   if e0 := getEnergy(id,kb) + chargeUnit
   /\ e := min(e0, maxCharge)
   /\ t := getTime(kb)
   /\ kb1 := addK(kb, clock(s t) (energy(id,e) @ s t)) .

  ceq doActT(id,kb,goTo(id,loc)) = kb1
   if t0 := getTime(kb)
   /\ l0 := getLoc(id,kb)
   /\ v := getVel(id,kb)
   /\ ff := distanceDir(l0,loc)
   /\ timeElapsed(dt0) @ t2 := getTimeElapsed(kb)
   --- Once we are able to link the model's timestamp with SITL's 
   --- This is a very rough estimate of arrival time
   /\ dt1 := (ff / v) + dt0
   /\ e0 := getEnergy(id,kb) - cost2locT(l0,loc,v,(ff / v)) 
****   /\ t1 := s t0
	 /\ t1 := round(dt1)
   /\ kb1 := addK((clock(t1)) (atloc(id,loc) @ t1) 
                  (energy(id,e0) @ t1),
									incVisitTimes(id,loc,t1,kb) ).

  ceq doActT(id,kb,goToW(id,loc,v)) = kb1
   if t0 := getTime(kb)
   /\ l0 := getLoc(id,kb)
   /\ ff := distanceDir(l0,loc)
   /\ timeElapsed(dt0) @ t2 := getTimeElapsed(kb)
   --- Once we are able to link the model's timestamp with SITL's 
   --- This is a very rough estimate of arrival time
   /\ dt1 := (ff / v) + dt0
   /\ e0 := getEnergy(id,kb) - cost2locT(l0,loc,v,(ff / v)) 
****   /\ t1 := s t0
   /\ t1 := round(dt1)
   /\ kb1 := addK((clock(t1)) (atloc(id,loc) @ t1) 
                  (energy(id,e0) @ t1),
                  incVisitTimes(id,loc,t1,kb) ).



  op time2Loc : Loc Loc FiniteFloat -> FiniteFloat .
	eq time2Loc(l0,loc,v) = distanceDir(l0,loc) / v .

  op cost2locT : Loc Loc FiniteFloat FiniteFloat -> FiniteFloat .
  eq cost2locT(l0,l1,v,dt) = costMv(v) * dt .

**** The drone should remember the expected time to visit a location
 op eLoc : Id Loc TimesList -> Info .
 eq hasId(id,eLoc(id,loc,times) @ t) = true .

 op updateELoc : Id Loc Time KB -> KB .
 eq updateELoc(id,loc,t1,(eLoc(id,loc,times) @ t) kb) = 
	              (eLoc(id,loc, (times ; t1)) @ t1) kb .
 eq updateELoc(id,loc,t1,kb) = kb [owise] .

**** eLoc item added upon first attempt to visit rather than initial state
 op updateELocKB : Id Loc FiniteFloat KB -> KB .
 eq updateELocKB(id,loc,v, (eLoc(id,loc,times) @ t0) clock(t) kb) =
     ((eLoc(id,loc,
        times ; round(float(t) + time2Loc(getLoc(id,kb),loc,v)) ) @ t)
      clock(t) kb)  .  

 eq updateELocKB(id,loc,v, clock(t) kb) =
      ((eLoc(id,loc, 
             round(float(t) + time2Loc(getLoc(id,kb),loc,v))) @ t) 
      clock(t) kb)  .
            
endfm


***(
ceq myActsA$(cl,id,loc0 ; locs, 
         (atloc(id,loc) @ t1) (myAlt(id,alt))
         (targetVel(id,v) @ t2) kb) = 
  (goToW(id,pt(x1,y1,z1),v)) 
  (goToW(id,pt(round(ffxnu1 * v) + x0,round(ffynu1 * v) + y0,z1),v))
  (goToW(id,pt(round(ffxnu2 * v) + x0,round(ffynu2 * v) + y0,z1),v))
  (goToW(id,pt(x1,y1,z1 + 5),v))
  (if z1 - 5 < alt then none else (goToW(id,pt(x1,y1,z1 - 5),v)) fi)   
  myActsA$(cl,id,locs,(atloc(id,loc) @ t1)(targetVel(id,v) @ t2) kb)
 if not inPrevention(id,kb)
 /\ pt(x2,y2,z2) := loc0
 /\ pt(x0,y0,z0) := loc 
 /\ dir(ffx1,ffy1,ffz1) := getNormVec(loc,pt(x2,y2,z0))
 *** Using the property of cos(alpha + beta) and sin(alpha + beta)
 *** sin(30) = 0.5 and cos(30) = 0.87
 /\ ffxnu1 := ffx1 * 0.87 - ffy1 * 0.5 *** + 30 degrees
 /\ ffynu1 := ffy1 * 0.87 + ffx1 * 0.5 *** + 30 degrees
 /\ ffxnu2 := ffx1 * 0.87 + ffy1 * 0.5 *** - 30 degrees
 /\ ffynu2 := ffy1 * 0.87 - ffx1 * 0.5 *** - 30 degrees
 /\ pt(x1,y1,z1) := pt(round(ffx1 * v) + x0,
                       round(ffy1 * v) + y0,
                       round(ffz1 * v) + z0) .
 )
