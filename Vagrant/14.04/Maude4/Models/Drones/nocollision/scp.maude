fth VALUATION is
  pr BOOL .
  inc SOFT-AGENTS .
  
  sort Grade . 
  op equivZero : Grade -> Bool .
  op _<_ : Grade  Grade -> Bool .
****  op _equiv_ : Grade x Grade -> Bool .  
 
  op val : Id KB Action  -> Grade .
***  op val : Id KB  -> Grade .

endfth

fmod SOLVE-SCP{Z :: VALUATION} is
   inc SOFT-AGENTS .

  vars v v0 v1 : Z$Grade .
  vars acts acts0 actset : ActSet .
  vars act1 act : Action .
  vars rks rks1 : RankSet{Z} .
  var id : Id .
  var kb : KB .
    
  sorts RankEle{Z} RankSet{Z} .
  op {_,_} : Z$Grade ActSet -> RankEle{Z} . 

  subsort RankEle{Z} < RankSet{Z} .
  op none : -> RankSet{Z} [ctor] .
  op __ : RankSet{Z} RankSet{Z} -> RankSet{Z} [ctor comm assoc id: none] .

  op getAct : RankSet{Z} -> ActSet .
  eq getAct({v,acts} rks) = acts getAct(rks) .
  eq getAct(none) = none .

  op updateRks : RankSet{Z} Action Z$Grade -> RankSet{Z} .
  ceq updateRks({v0,acts0} rks,act1,v1) = {v0,acts0} rks if v1 < v0 .
  ceq updateRks({v0,acts0} rks,act1,v1) = updateRks(rks,act1,v1) 
   if v0 < v1 .
  eq updateRks({v1,acts0} rks,act1,v1) = {v1,acts0 act1} rks .
  eq updateRks(rks,act1,v1) = 
      if equivZero(v1) then rks else {v1,act1} rks fi [owise] .
    
****  op solveSCP : Id KB ActSet -> ActSet .
  eq solveSCP(id,kb,acts) = solveSCP$(id,kb,acts,none) .

  op solveSCP$ : Id KB ActSet RankSet{Z} -> ActSet .
  eq solveSCP$(id,kb,none,rks) = getAct(rks) .
  ceq solveSCP$(id,kb,act actset,rks) = solveSCP$(id,kb,actset,rks1) 
   if v0 := val(id,kb,act)
   /\ rks1 := updateRks(rks,act,v0) .

endfm


**** Boolean Valuation Safe or Not

fmod BVAL is
  pr CONVERSION .

**** Grade is BVal  
  vars b1 b2 : BVal .
  sort BVal .

  op _<_ : BVal BVal -> Bool  .
  op equivZero : BVal -> Bool .

  ops bot top : -> BVal .
  eq  bot < top = true .
  eq x:BVal < y:BVal = false [owise] .

  eq equivZero(bot) = true .
  eq equivZero(top) = false .  

endfm

fmod TRIVAL is
  pr CONVERSION .

**** Grade is BVal  
  vars b1 b2 : TriVal .
  sort TriVal .

  op _<_ : TriVal TriVal -> Bool  .
  op equivZero : TriVal -> Bool .

  ops bot mid top : -> TriVal .
  eq  bot < top = true .
  eq  bot < mid = true .
  eq  mid < top = true .
  eq x:TriVal < y:TriVal = false [owise] .

  eq equivZero(bot) = true .
  eq equivZero(top) = false .  
  eq equivZero(mid) = false .  

endfm

**** safety valuation function for energy concern
**** defines eval
fmod VAL-ENERGY is
  inc SOFT-AGENTS .
  inc CONVERSION .
  inc BVAL .
  inc MODEL-KNOWLEDGE .

  var cl : Class .
  vars kb kb' : KB .
  vars id st : Id .
  vars cx cy cz e v : FiniteFloat .
  vars loc locb : Loc .
  vars t0 t t1 x1 y1 z1 x0 y0 z0 : Nat .
  var act : Action .
  vars loc0 loc1 loc2 : Loc .
  var locs : LocSet .
  vars ni ni0 ni1 : Float .
  vars dir dir1 : Dir .
  var dummy : BVal .
 
  op val-energy : Id KB  -> BVal .
  eq val-energy(id,(energy(id,e) @ t0) kb) = 
   if e > getCaution(id,kb) then top else bot fi .

  op val-energy : Id KB Action  -> BVal .
  eq val-energy(id,(myHome(id,locb)) kb,goTo(id,loc1)) = 
   if locb == loc1 then top else  val-energy(id,doAct(id,kb,goTo(id,loc1))) fi .

  eq val-energy(id,(myHome(id,locb)) kb,goToW(id,loc1,v)) = 
   if locb == loc1 then top else val-energy(id,doAct(id,kb,goToW(id,loc1,v))) fi .

  eq val-energy(id,kb,act) = bot [owise] .  **** shouldn't happen

endfm

fmod UVAL is
  pr CONVERSION .

***** Grade is Float
  vars u1 u2 : Float .
  
  op equivZero : Float -> Bool .
  eq equivZero(0.0) = true .
  eq equivZero(u1) = false [owise] .

endfm

fmod FFVAL is
  pr CONVERSION .

  sort FF .
  op {_,_} : FiniteFloat FiniteFloat -> FF .

***** Grade is Float
  vars u1 u2 : FF .
  vars fb fc fb0 fc0 : FiniteFloat .

*****!!! assume cost not 0.0
  op _<_ : FF FF -> Bool  .
  eq {fb,fc} < {fb0,fc0} 
   = (if (fb < fb0) or ((fb == fb0) and (fc > fc0))
     then true
     else (if (fb == fb0 and (fc < fc0))
           then false
           else (if (fb / fc ) < (fb0 / fc0 )
                 then true else false fi)
     fi) fi) .

  op equivZero : FF -> Bool .
  --- Anything with benefit zero is zero.
  eq equivZero({0.0,fc}) = true . 
  eq equivZero(u1) = false [owise] .

***(
  op _equiv_ : Float Float -> Bool [comm] .
  eq u1 equiv u2 = (u1 == u2) . 
  eq u1 <= u2 = (u1 < u2) or (u1 equiv u2) . 
)

endfm

***(
This valuatios is for just visiting a point once
)

fmod VAL-VISITS is 
  inc SOFT-AGENTS .
  inc CONVERSION .
  inc FFVAL .
  inc MODEL-KNOWLEDGE .

  vars kb kb' kb1 kb2 kb3 : KB .
  vars id st : Id .
  vars x y x1 y1 z1 x0 y0 z0 m n i : Nat .
  var act : Action .
  vars loc loc0 loc1 loc2 : Loc .
  var locs locs0 locs1 : LocList .
  vars dir dir1 : Dir .
  vars t t0 t1 : Time .
  vars st1 st2 v dt ff1 ff2 : FiniteFloat .
  var times : TimesList .
  
  op valueCS : Id KB -> FiniteFloat .
  op benefit : Id KB Action -> FiniteFloat .
  op cost : Id KB Action -> FiniteFloat .
  op val-visits : Id KB Action  -> FF .

  ceq benefit(id,kb,goToW(id,loc,v)) = st2 - st1
   if kb1 := doActT(id,kb,goToW(id,loc,v))
   /\ st1 := valueCS(id,kb)
   /\ st2 := valueCS(id,kb1) .

  eq valueCS(id,(clock(t)) (visitTimes(id,loc, times ; t0) @ t1) kb)
   = valueCS(id,(clock(t)) kb) + 1.0 .
  eq valueCS(id,(clock(t)) 
      (atloc(id,loc0) @ t0) (visitTimes(id,loc,nil) @ t1) kb) = 
    valueCS(id,(clock(t)) kb) + exp(- 0.1 * distanceFF(loc0,loc)) .
  eq valueCS(id,kb) = 0.0 [owise] . *** not visited sites have 

  ceq cost(id,kb,goToW(id,loc,v)) = cost2locT(loc0,loc,v,time2Loc(loc0,loc,v)) 
   if loc0 := getLoc(id,kb) .

  eq val-visits(id,kb,act) 
   = {benefit(id,kb,act),cost(id,kb,act)} .

  eq equivZero({ff1,ff2}) = ff1 == 0.0 .

endfm

fmod VAL-NO-COLLISION is
  inc BVAL .
  inc MODEL-KNOWLEDGE .

  var id : Id .
  vars ffx ffx0 ffx1 ffx2 ffx3 ffy ffy0 ffy1 ffy2 ffy3 ffz ffz0 
       ff ffz1 safety delta v dxc dyc dxl dyl cross
       maxT minT  dx dx' dy dy' dz dz' a b c d : FiniteFloat .
  vars loc0 loc1 loc2 : Loc .
  vars t0 t1 : Time .
  vars x0 y0 z0 x1 y1 z1 x2 y2 z2 : Int .
  var kb : KB .
  var act : Action .

  op val-no-collision : Id KB Action -> BVal .
  ceq val-no-collision(id,(atloc(id,loc0) @ t0) (statObj(id,loc1,loc2) @ t1) kb, act) = bot 
   if tooClose(id,loc1,loc2,kb,act) .
  ceq val-no-collision(id,(atloc(id,loc0) @ t0) 
                          (movObj(id,loc1,ffx,ffy,ffz) @ t1) kb,act) = bot 
   if colliding(id,loc0,loc1,ffx,ffy,ffz,kb,act) .
  eq val-no-collision(id,kb,act) = top [owise] . 

  *** The safety parameter may be dependent on the velocity. 
  *** this would lead to more precise evaluation.
  op tooClose : Id Loc Loc KB Action -> Bool .
  ceq tooClose(id,pt(x1,y1,z1),pt(x2,y2,z2),
      safetyStat(id,safety) kb, goToW(id,pt(x0,y0,z0),v))
    = (if d >= safety then false 
      else 
        betweenPoints(ffx3,ffy3,pt(x1,y1,z1),pt(x2,y2,z2))
        or 
        distanceFF(pt(x1,y1,0),pt(round(ffx3),round(ffy3),0)) < safety 
        or 
        distanceFF(pt(x2,y2,0),pt(round(ffx3),round(ffy3),0)) < safety
      fi)
   if ffx0 := float(x0)
   /\ ffx1 := float(x1)
   /\ ffx2 := float(x2)
   /\ ffy0 := float(y0)
   /\ ffy1 := float(y1)
   /\ ffy2 := float(y2)
   /\ a := if (ffx2 - ffx1) == 0.0 then 1.0 
                     else  (ffy2 - ffy1) / (ffx2 - ffx1) fi 
   /\ b := if (ffx2 - ffx1) == 0.0 then 0.0  
                         else - 1.0 fi
   /\ c := if (ffx2 - ffx1) == 0.0 then - ffx1  
             else (- (a * ffx1)) + ffy1 fi 
   /\ ff := a ^ 2.0 + b ^ 2.0
   --- /\ d := abs((ffy2 - ffy1) * ffx0 - (ffx2 - ffx1) * ffx0 + ffx2 * ffy1 - ffy2 * ffy1) / sqrt((ffy2 - ffy1) ^ 2.0 + (ffx2 - ffx1) ^ 2.0)
   /\ d := abs(a * ffx0 + b * ffy0 + c) / sqrt(ff) 
   /\ ffx3 := (b * (b * ffx0 - a * ffy0) - a * c) / ff 
   /\ ffy3 := (a * (- b * ffx0 + a * ffy0) - b * c) / ff 
   [print ffx3 " " ffy3 " " d].

*** http://stackoverflow.com/questions/11907947/how-to-check-if-a-point-lies-on-a-line-between-2-other-points/11912171
  op betweenPoints : FiniteFloat FiniteFloat Loc Loc -> Bool .
  ceq betweenPoints(ffx0,ffy0,pt(x1,y1,z1),pt(x2,y2,z2)) = 
     (if not (cross == 0.0) then false 
     else 
      (if abs(dxl) > abs(dyl) then 
        (if dxl > 0.0 then ffx1 <= ffx0 and ffx0 <= ffx2 
                    else ffx2 <= ffx0 and ffx0 <= ffx1
         fi)
      else
        (if dyl > 0.0 then ffy1 <= ffy0 and ffy0 <= ffy2 
                    else ffy2 <= ffy0 and ffy0 <= ffy1
         fi)
      fi)
     fi) 
   if ffx1 := float(x1) 
   /\ ffx2 := float(x2) 
   /\ ffy1 := float(y1) 
   /\ ffy2 := float(y2)
   /\ dxc := ffx0 - ffx1
   /\ dyc := ffy0 - ffy1
   /\ dxl := ffx2 - ffx1
   /\ dyl := ffy2 - ffy1
   /\ cross := dxc * dyl - dyc * dxl  .

  op colliding : Id Loc Loc FiniteFloat FiniteFloat FiniteFloat KB Action -> Bool .
  ceq colliding(id,loc0,loc1,ffx1,ffy1,ffz1,
                  (safetyMv(id,safety,delta)) kb,
                  goToW(id,loc2,v)) = 
                  maxT >= minT and maxT > 0.0 and minT < delta
   if pt(x0,y0,z0) := loc0
   /\ pt(x1,y1,z1) := loc1
   /\ dir(ffx0,ffy0,ffz0) := timesDir(v,getNormVec(loc0,loc2))
   /\ dx := (float(x1 - x0) + safety) / (ffx0 - ffx1)
   /\ dx' := (float(x1 - x0) - safety) / (ffx0 - ffx1)
   /\ dy := (float(y1 - y0) + safety) / (ffy0 - ffy1)
   /\ dy' := (float(y1 - y0) - safety) / (ffy0 - ffy1)
   /\ dz := (float(z1 - z0) + safety) / (ffz0 - ffz1)  
   /\ dz' := (float(z1 - z0) - safety) / (ffz0 - ffz1)
   /\ maxT := max(dx,max(dy,dz))
   /\ minT := min(dx',min(dy',dz')) .

endfm

fmod VAL-VISITS-ENERGY is
  inc VAL-VISITS .
  inc VAL-ENERGY .

  var id : Id . 
  var kb : KB . 
  var act : Action .
  vars b1 b2 : BVal .
  vars u1 u2 : FF .
  
  sort TFFVal .
  op {_,_} : BVal FF -> TFFVal .

  op val : Id KB -> TFFVal .
  op val : Id KB Action -> TFFVal .
  eq val(id,kb) = {val-energy(id,kb),{1.0,1.0}} .
  eq val(id,kb,act) = {val-energy(id,kb,act),val-visits(id,kb,act)} .

  op _<_ : TFFVal TFFVal -> Bool .
  op equivZero : TFFVal -> Bool .

  eq {b1,u1} < {b2,u2} = (b1 < b2) or (b1 == b2 and u1 < u2) .
  eq equivZero({b1,u1}) = (equivZero(b1)) or (equivZero(u1)) .

endfm

fmod VAL-VISITS-ENERGY-COLLISION is
  inc VAL-VISITS .
  inc VAL-ENERGY .
  inc VAL-NO-COLLISION .

  var id : Id . 
  var kb : KB . 
  var act : Action .
  vars b1 b2 b1' b2' : BVal .
  vars u1 u2 : FF .
  
  *** Collision Energy Pics
  sort TTFFVal .
  op {_,_,_} : BVal BVal FF -> TTFFVal .

  op val : Id KB -> TTFFVal .
  op val : Id KB Action -> TTFFVal .
  --- eq val(id,kb) = {val-energy(id,kb),{1.0,1.0}} .
  eq val(id,kb,act) = {val-no-collision(id,kb,act),
                       val-energy(id,kb,act),
                       val-visits(id,kb,act)} .

  op _<_ : TTFFVal TTFFVal -> Bool .
  op equivZero : TTFFVal -> Bool .

  eq {b1',b1,u1} < {b2',b2,u2} = (b1' < b2') or
                                 (b1' == b2' and b1 < b2) or
                                 (b1' == b2' and b1 == b2 and u1 < u2) .

  eq equivZero({b1',b1,u1}) = (equivZero(b1')) or (equivZero(b1)) or (equivZero(u1)) .

endfm


view  valuation2valvisit from VALUATION to VAL-VISITS-ENERGY is
  sort Grade to TFFVal .
endv  


view  valuation2valvisitcollision from VALUATION to VAL-VISITS-ENERGY-COLLISION is
  sort Grade to TTFFVal .
endv 
