fth VALUATION is
  pr BOOL .
  inc SOFT-AGENTS .
  
  sort Grade . 
  op equivZero : Grade -> Bool .
  op _<_ : Grade  Grade -> Bool .
****  op _equiv_ : Grade x Grade -> Bool .  
 
  op val : Id KB Action  -> Grade .
***  op val : Id KB  -> Grade .

endfth

fmod SOLVE-SCP{Z :: VALUATION} is
   inc SOFT-AGENTS .

  vars v v0 v1 : Z$Grade .
  vars acts acts0 actset : ActSet .
  vars act1 act : Action .
  vars rks rks1 : RankSet{Z} .
  var id : Id .
  var kb : KB .
    
  sorts RankEle{Z} RankSet{Z} .
  op {_,_} : Z$Grade ActSet -> RankEle{Z} . 

  subsort RankEle{Z} < RankSet{Z} .
  op none : -> RankSet{Z} [ctor] .
  op __ : RankSet{Z} RankSet{Z} -> RankSet{Z} [ctor comm assoc id: none] .

  op getAct : RankSet{Z} -> ActSet .
  eq getAct({v,acts} rks) = acts getAct(rks) .
  eq getAct(none) = none .

  op updateRks : RankSet{Z} Action Z$Grade -> RankSet{Z} .
  ceq updateRks({v0,acts0} rks,act1,v1) = {v0,acts0} rks if v1 < v0 .
  ceq updateRks({v0,acts0} rks,act1,v1) = updateRks(rks,act1,v1) 
   if v0 < v1 .
  eq updateRks({v1,acts0} rks,act1,v1) = {v1,acts0 act1} rks .
  eq updateRks(rks,act1,v1) = 
      if equivZero(v1) then rks else {v1,act1} rks fi [owise] .
    
****  op solveSCP : Id KB ActSet -> ActSet .
  eq solveSCP(id,kb,acts) = solveSCP$(id,kb,acts,none) .

  op solveSCP$ : Id KB ActSet RankSet{Z} -> ActSet .
  eq solveSCP$(id,kb,none,rks) = getAct(rks) .
  ceq solveSCP$(id,kb,act actset,rks) = solveSCP$(id,kb,actset,rks1) 
   if v0 := val(id,kb,act)
   /\ rks1 := updateRks(rks,act,v0) .

endfm


**** Boolean Valuation Safe or Not

fmod BVAL is
  pr CONVERSION .

**** Grade is BVal  
  vars b1 b2 : BVal .
  sort BVal .

  op _<_ : BVal BVal -> Bool  .
  op equivZero : BVal -> Bool .

  ops bot top : -> BVal .
  eq  bot < top = true .
  eq x:BVal < y:BVal = false [owise] .

  eq equivZero(bot) = true .
  eq equivZero(top) = false .  

endfm

fmod TRIVAL is
  pr CONVERSION .

**** Grade is BVal  
  vars b1 b2 : TriVal .
  sort TriVal .

  op _<_ : TriVal TriVal -> Bool  .
  op equivZero : TriVal -> Bool .

  ops bot mid top : -> TriVal .
  eq  bot < top = true .
  eq  bot < mid = true .
  eq  mid < top = true .
  eq x:TriVal < y:TriVal = false [owise] .

  eq equivZero(bot) = true .
  eq equivZero(top) = false .  
  eq equivZero(mid) = false .  

endfm

**** safety valuation function for energy concern
**** defines eval
fmod VAL-ENERGY is
  inc SOFT-AGENTS .
  inc CONVERSION .
  inc BVAL .
  inc MODEL-KNOWLEDGE .

  var cl : Class .
  vars kb kb' : KB .
  vars id st : Id .
  vars cx cy cz e v : FiniteFloat .
  vars loc locb : Loc .
  vars t0 t t1 x1 y1 z1 x0 y0 z0 : Nat .
  var act : Action .
  vars loc0 loc1 loc2 : Loc .
  var locs : LocSet .
  vars ni ni0 ni1 : Float .
  vars dir dir1 : Dir .
  var dummy : BVal .
 
  op val-energy : Id KB  -> BVal .
  eq val-energy(id,(energy(id,e) @ t0) kb) = 
   if e > getCaution(id,kb) then top else bot fi .

  op val-energy : Id KB Action  -> BVal .
  eq val-energy(id,(myHome(id,locb)) kb,goTo(id,loc1)) = 
   if locb == loc1 then top else  val-energy(id,doAct(id,kb,goTo(id,loc1))) fi .

  eq val-energy(id,(myHome(id,locb)) kb,goToW(id,loc1,v)) = 
   if locb == loc1 then top else val-energy(id,doAct(id,kb,goToW(id,loc1,v))) fi .

  eq val-energy(id,kb,act) = bot [owise] .  **** shouldn't happen

endfm

fmod UVAL is
  pr CONVERSION .

***** Grade is Float
  vars u1 u2 : Float .
  
  op equivZero : Float -> Bool .
  eq equivZero(0.0) = true .
  eq equivZero(u1) = false [owise] .

endfm

fmod FFVAL is
  pr CONVERSION .

  sort FF .
  op {_,_} : FiniteFloat FiniteFloat -> FF .

***** Grade is Float
  vars u1 u2 : FF .
  vars fb fc fb0 fc0 : FiniteFloat .

*****!!! assume cost not 0.0
  op _<_ : FF FF -> Bool  .
  eq {fb,fc} < {fb0,fc0} 
   = (if (fb < fb0) or ((fb == fb0) and (fc > fc0))
     then true
     else (if (fb == fb0 and (fc < fc0))
           then false
           else (if (fb / fc ) < (fb0 / fc0 )
                 then true else false fi)
     fi) fi) .

  op equivZero : FF -> Bool .
  --- Anything with benefit zero is zero.
  eq equivZero({0.0,fc}) = true . 
  eq equivZero(u1) = false [owise] .

***(
  op _equiv_ : Float Float -> Bool [comm] .
  eq u1 equiv u2 = (u1 == u2) . 
  eq u1 <= u2 = (u1 < u2) or (u1 equiv u2) . 
)

endfm

***(
This valuatios is for just visiting a point once
)

fmod VAL-VISITS is 
  inc SOFT-AGENTS .
  inc CONVERSION .
  inc FFVAL .
  inc MODEL-KNOWLEDGE .

  vars kb kb' kb1 kb2 kb3 : KB .
  vars id st : Id .
  vars x y x1 y1 z1 x0 y0 z0 m n i : Nat .
  var act : Action .
  vars loc loc0 loc1 loc2 : Loc .
  var locs locs0 locs1 : LocList .
  vars dir dir1 : Dir .
  vars t t0 t1 : Time .
  vars st1 st2 v dt ff1 ff2 : FiniteFloat .
  var times : TimesList .
  
  op valueCS : Id KB -> FiniteFloat .
  op benefit : Id KB Action -> FiniteFloat .
  op cost : Id KB Action -> FiniteFloat .
  op val-visits : Id KB Action  -> FF .

  ceq benefit(id,kb,goToW(id,loc,v)) = st2 - st1
   if kb1 := doActT(id,kb,goToW(id,loc,v))
   /\ st1 := valueCS(id,kb)
   /\ st2 := valueCS(id,kb1) .

  eq valueCS(id,(clock(t)) (visitTimes(id,loc, times ; t0) @ t1) kb)
   = valueCS(id,(clock(t)) kb) + 1.0 .
  eq valueCS(id,(clock(t)) 
      (atloc(id,loc0) @ t0) (visitTimes(id,loc,nil) @ t1) kb) = 
    valueCS(id,(clock(t)) kb) + exp(- 0.1 * distanceFF(loc0,loc)) .
  eq valueCS(id,kb) = 0.0 [owise] . *** not visited sites have 

  ceq cost(id,kb,goToW(id,loc,v)) = cost2locT(loc0,loc,v,time2Loc(loc0,loc,v)) 
   if loc0 := getLoc(id,kb) .

  eq val-visits(id,kb,act) 
   = {benefit(id,kb,act),cost(id,kb,act)} .

  eq equivZero({ff1,ff2}) = ff1 == 0.0 .

endfm

fmod VAL-NO-COLLISION is
  inc TRIVAL .
  inc MODEL-KNOWLEDGE .

  var id : Id .
  vars ffx ffx0 ffx1 ffx2 ffx3 ffy ffy0 ffy1 ffy2 ffy3 ffz ffz0 
       ff ffz1  delta v dxc dyc dxl dyl cross safety prevention
       maxT minT  dx dx' dy dy' dz dz' a b c d  : FiniteFloat .
  vars loc0 loc1 loc2 : Loc .
  vars t0 t1 : Time .
  vars x0 y0 z0 x1 y1 z1 x2 y2 z2 : Int .
  var kb : KB .
  var act : Action .
  var tval : TriVal .
  var locs : LocList .
  var dir : Dir .

  op val-no-collision : Id KB Action -> TriVal .
  op val-no-collision$ : Id KB Action TriVal -> TriVal .

  eq val-no-collision(id,kb,act) = val-no-collision$(id,kb,act,top) .

  eq val-no-collision$(id,(atloc(id,loc0) @ t0) 
                 (statObj(id,loc1,loc2,locs,dir) @ t1)
                 (safetyStat(id,safety,prevention)) kb,
                  act, tval) = 
   (if inBox(id,loc1,loc2,safety,act) then bot 
   else (if inBox(id,loc1,loc2,prevention,act) then 
         val-no-collision$(id,(atloc(id,loc0) @ t0) 
                 (safetyStat(id,safety,prevention)) kb,
                  act, mid)
         else val-no-collision$(id,(atloc(id,loc0) @ t0) 
                 (safetyStat(id,safety,prevention)) kb,
                  act, tval) fi)
   fi) .

  ceq val-no-collision$(id,(atloc(id,loc0) @ t0) 
      (movObj(id,loc1,ffx,ffy,ffz) @ t1) kb,act,tval) = bot 
   if colliding(id,loc0,loc1,ffx,ffy,ffz,kb,act) .

  eq val-no-collision$(id,kb,act,tval) = tval [owise] .

  *** The safety parameter may be dependent on the velocity. 
  *** this would lead to more precise evaluation.
  op inBox : Id Loc Loc FiniteFloat Action -> Bool .
  eq inBox(id,loc1,loc2,safety, goToW(id,loc0,v))
    = inBox(id,loc1,loc2,safety,loc0) .

  op colliding : Id Loc Loc FiniteFloat FiniteFloat FiniteFloat KB Action -> Bool .
  ceq colliding(id,loc0,loc1,ffx1,ffy1,ffz1,
                  (safetyMv(id,safety,delta)) kb,
                  goToW(id,loc2,v)) = 
                  maxT >= minT and maxT > 0.0 and minT < delta
   if pt(x0,y0,z0) := loc0
   /\ pt(x1,y1,z1) := loc1
   /\ dir(ffx0,ffy0,ffz0) := timesDir(v,getNormVec(loc0,loc2))
   /\ dx := (float(x1 - x0) + safety) / (ffx0 - ffx1)
   /\ dx' := (float(x1 - x0) - safety) / (ffx0 - ffx1)
   /\ dy := (float(y1 - y0) + safety) / (ffy0 - ffy1)
   /\ dy' := (float(y1 - y0) - safety) / (ffy0 - ffy1)
   /\ dz := (float(z1 - z0) + safety) / (ffz0 - ffz1)  
   /\ dz' := (float(z1 - z0) - safety) / (ffz0 - ffz1)
   /\ maxT := max(dx,max(dy,dz))
   /\ minT := min(dx',min(dy',dz')) .

endfm

fmod VAL-VISITS-ENERGY is
  inc VAL-VISITS .
  inc VAL-ENERGY .

  var id : Id . 
  var kb : KB . 
  var act : Action .
  vars b1 b2 : BVal .
  vars u1 u2 : FF .
  
  sort TFFVal .
  op {_,_} : BVal FF -> TFFVal .

  op val : Id KB -> TFFVal .
  op val : Id KB Action -> TFFVal .
  eq val(id,kb) = {val-energy(id,kb),{1.0,1.0}} .
  eq val(id,kb,act) = {val-energy(id,kb,act),val-visits(id,kb,act)} .

  op _<_ : TFFVal TFFVal -> Bool .
  op equivZero : TFFVal -> Bool .

  eq {b1,u1} < {b2,u2} = (b1 < b2) or (b1 == b2 and u1 < u2) .
  eq equivZero({b1,u1}) = (equivZero(b1)) or (equivZero(u1)) .

endfm

fmod VAL-VISITS-ENERGY-COLLISION is
  inc VAL-VISITS .
  inc VAL-ENERGY .
  inc VAL-NO-COLLISION .

  var id : Id . 
  var kb : KB . 
  var act : Action .
  vars b1 b2 : BVal .
  vars t1 t2 : TriVal .
  vars u1 u2 : FF .
  vars ttffval1 ttffval2 : TTFFVal .
  vars bn1 bn2 cs1 cs2 : FiniteFloat .  
  
  *** Collision Energy Pics
  sort TTFFVal .
  op {_,_,_} : TriVal BVal FF -> TTFFVal .

  op val : Id KB -> TTFFVal .
  op val : Id KB Action -> TTFFVal .
  --- eq val(id,kb) = {val-energy(id,kb),{1.0,1.0}} .
  eq val(id,kb,act) = {val-no-collision(id,kb,act),
                       val-energy(id,kb,act),
                       val-visits(id,kb,act)} .

  op _<_ : TTFFVal TTFFVal -> Bool .
  op equivZero : TTFFVal -> Bool .

  eq {top,b1,u1} < {top,b2,u2} = (b1 < b2) or
                                 (b1 == b2 and u1 < u2) .
  eq {bot,b1,u1} < {top,b2,u2} = true .
  eq {bot,b1,u1} < {mid,b2,u2} = true .
  eq {mid,b1,{bn1,cs1}} < {top,b2,{bn2,cs2}} = 
                          (b1 < b2) or (b1 == b2 and bn2 > 0.0) .
  eq {top,b1,{bn1,cs1}} < {mid,b2,{bn2,cs2}} = 
                          (b1 < b2) or 
                          (b1 == b2 and bn1 <= 0.0 and bn2 > 0.0) .
  eq {mid,b1,u1} < {mid,b2,u2} = (b1 < b2) or 
                                 (b1 == b2 and u1 < u2) .
 
  eq ttffval1 < ttffval2 = false [owise] .

  eq equivZero({t1,b1,u1}) = (equivZero(t1)) or (equivZero(b1)) .

endfm

fmod IN-PREVENSION is
  inc TRIVAL .

  op val : Id KB -> TriVal .
  op val : Id KB Action -> TriVal .

  eq var(id,kb) = if inSafeBox(id,kb) then bot 
                  else (if inPrevention(id,kb,none) == none then top 
                        else mid fi) fi .
  eq var(id,kb,act) = var(id,doAct(id,kb,act)) .

endfm

fmod TOWARDS-GOAL is
  inc BVAL .


endfm

fmod SAFE-TO-REACH is
  inc BVAL .
  
endfm

view  valuation2valvisit from VALUATION to VAL-VISITS-ENERGY is
  sort Grade to TFFVal .
endv  

view  valuation2valvisitcollision from VALUATION to VAL-VISITS-ENERGY-COLLISION is
  sort Grade to TTFFVal .
endv 
