fmod MODEL-KNOWLEDGE is
  inc SOFT-AGENTS .
	inc CONVERSION .

  vars t t0 t1 t2 : Time .
  vars x y x1 y1 x0 y0 z0 z1 z : Int .
  vars id id0 id1 : Id .
	var cl : Class .
  vars l l0 l1 l2 l3 loc : Loc .
  vars senl0 senl1 : SenLoc .
  vars gl0 gl1 gl2 gl3 : GridLoc .
  vars ekb ekb0 ekb1 kb  lkb kb1 lkb0  :  KB .
  var dir dir0 dir1 : Dir .
  vars e e0 e1 ff0 ff1 ffx ffy ffz ff ffx0 ffx1 ffy0 ffy1 ffz0 ffz1 v sx sy sz : FiniteFloat .
	
*** parameters
  --- ops gridX gridY gridZ : -> Nat .
  --- for shifting coordinates 0,0
  ops senXLow senYLow senZLow : -> FiniteFloat . 
  ops gridStepX gridStepY gridStepZ : -> FiniteFloat .
  op edgeX : -> Int .

  --- eq gridStepX = floor((senXHigh - senXLow) / float(gridX)) . 
  --- eq gridStepY = floor((senYHigh - senYLow) / float(gridY)) . 
  --- eq gridStepZ = floor((senZHigh - senZLow) / float(gridZ)) . 

  op comDistance : -> Nat .


  op chargeUnit : -> FiniteFloat .
  op maxCharge : -> FiniteFloat .      --- stop charging when full
 
  op botDelay : -> Nat .
  op costMv : -> FiniteFloat .

*** class
  op Bot : -> Class .
  op Station : -> Class .

*** grid-location
  sorts GridLoc SenLoc .
  op {_,_} : SenLoc GridLoc -> Loc .
  op pt : Int Int Int -> GridLoc .
  op senLoc : FiniteFloat FiniteFloat FiniteFloat -> SenLoc .
  op sen2grid : SenLoc -> GridLoc .

  eq sen2grid(senLoc(ffx,ffy,ffz)) = 
       pt(rat(floor((ffx - senXLow) / gridStepX)), 
          rat(floor((ffy - senYLow) / gridStepY)),
          rat(floor((ffz - senZLow) / gridStepZ)))
    .

  op equiv : Loc Loc -> Bool .
  eq equiv({senl0,gl0},{senl1,gl0}) = true .
  eq equiv(l0,l1) = false [owise] .

 op getSenLoc : Loc -> SenLoc .
 eq getSenLoc({senl0,gl0}) = senl0 .

 op getGridLoc : Loc -> GridLoc .
 eq getGridLoc({senl0,gl0}) = gl0 .

 op incZ : Loc FiniteFloat -> Loc .
 ceq incZ(loc,ff) = {senl0,msen2grid(senl0)}
  if senLoc(ffx,ffy,ffz) := getSenLoc(loc)
  /\ senl0 := senLoc(ffx,ffy,ffz + ff) .

**** Bot specific knowledge
  op myY : Id Nat -> Info .    **** myY is the track bot is moving along
  op myDir : Id Dir -> Info .  **** myDir is the direction the bot is heading
****  op velocity : Id FiniteFloat -> Info .  **** myDir is the direction the bot is heading
  ops vEdge : Id GridLoc GridLoc -> Info .

  op getMyY : Id KB  -> [Nat] .  
  eq getMyY(id, kb (myY(id,y) @ t)) = y .
  
  op getMyDir : Id KB  -> [Dir] .  
  eq getMyDir(id, kb myDir(id,dir) @ t) = dir .

  op energy : Id FiniteFloat -> Info [ctor] .
  eq hasId(id,energy(id,e) @ t) = true .

  op getEnergy : Id KB -> FiniteFloat .
  eq getEnergy(id, (energy(id,e) @ t) lkb ) = e .
  eq getEnergy(id,lkb) = 0.0 [owise] .

  op caution : Id FiniteFloat -> Info [ctor] .
  eq hasId(id,caution(id,e) @ t) = true .
	
  op getCaution : Id KB -> FiniteFloat .
  eq getCaution(id, (caution(id,e) @ t) lkb ) = e .
  eq getCaution(id,lkb ) = 1.0 [owise] .

  op rand : Id Nat -> Info .

  op vel : Id FiniteFloat -> Info .  **** myVel is the absolute velocity
  eq hasId(id,vel(id,ff) @ t) = true .

  op getVel : Id KB -> FiniteFloat .
  eq getVel(id, (vel(id,ff) @ t) lkb ) = ff .
  eq getVel(id,lkb ) = 0.0 [owise] .

******** bot  actions

  op mv : Id Dir FiniteFloat -> Action .
  op charge : Id -> Action .
  
  --- distance
  --- Probably will need to change this to be more vectorial
  eq distance({senl0,pt(x0,y0,z0)},{senl1,pt(x1,y1,z1)}) = 
    abs(x0 - x1) + abs(y0 - y1) + abs(z0 - z1) .
  
  --- location occupied if there is a bot at the location
  op occupied : Loc KB -> Bool .
  op occupied : GridLoc KB -> Bool .
  eq occupied({senl0,gl0},(atloc(id,{senl1,gl0}) @ t) class(id,Bot) ekb) = true .
  eq occupied(l0, ekb) = false [owise] .

  eq occupied(gl0,(atloc(id,{senl1,gl0}) @ t) class(id,Bot) ekb) = true .
  eq occupied(gl0, ekb) = false [owise] .

  --- in contact if distance is less than or equal to comDistance
  eq inContact(id0,id1,ekb) 
   = distance(getLoc(id0,ekb),getLoc(id1,ekb)) <= comDistance .

  sort Dir . 
  ops E W N S : -> Dir .  **** east (right) west (left) north south
  --- dir(x,y,z) where -1 <= x,y,z <= 1.0
  op dir : FiniteFloat FiniteFloat FiniteFloat -> Dir .
  eq E = dir(1.0,0.0,0.0) .
  eq W = dir(-1.0,0.0,0.0) .
  eq N = dir(0.0,1.0,0.0) . 
  eq S = dir(0.0,-1.0,0.0) . 

  op reverseDir : Dir -> Dir .
  eq reverseDir(dir) = if dir == E then W 
                       else (if dir == W then E 
                         else (if dir == N then S 
                               else (if dir == S then N else dir fi)
                               fi)
                         fi)
                       fi .
**** model of expected result of move actions
  op senMove : SenLoc Dir FiniteFloat -> SenLoc .
  eq senMove(senLoc(ffx,ffy,ffz),dir(ffx0,ffy0,ffz0),v) = 
       senLoc(ffx + ffx0 * v,ffy + ffy0 * v,ffz + ffz0 * v) .
       
  op round : FiniteFloat -> Int .
  ceq round(sx) =
    (if (sx >= 0.0)
      then (if r:Rat < 1/2 then floor(rat(sx)) else ceiling(rat(sx)) fi)
      else (if r:Rat < 1/2 then ceiling(rat(sx)) else floor(rat(sx)) fi)
    fi)
    if r:Rat := rat(sx) - floor(rat(sx)) .
    op msen2grid : SenLoc -> GridLoc .
    eq msen2grid(senLoc(sx,sy,sz)) = pt(round(sx / gridStepX),round(sy / gridStepY),round(sz / gridStepZ)) .

  op doMv : Loc Dir FiniteFloat -> Loc .
  ceq doMv({senl0,gl0},dir,v) = {senl1,gl1}
   if senl1 := senMove(senl0,dir,v)
   /\ gl1 := sen2grid(senl1) .

  --- ceq doMv({senl0,gl0,dir,v) = 
  --- {senl0,pt(x0 + 1,y0,z0)} 
  ---  if dir == E .
  --- ceq doMv({senl0,pt(x0,y0,z0)},dir) = {senl0,pt(x0 - 1,y0,z0)} 
  ---  if dir == W .
  --- ceq doMv({senl0,pt(x0,y0,z0)},dir) = {senl0,pt(x0,y0 + 1,z0)} 
  ---  if dir == N .
  --- ceq doMv({senl0,pt(x0,y0,z0)},dir) = {senl0,pt(x0,y0 - 1,z0)} 
  ---  if dir == S .
  eq doMv(l0,dir,v) = l0 [owise] .


*** partial order
  eq atloc(id,l0) @ t0 << atloc(id,l1) @ t1 = t0 < t1 .
  eq (myY(id,y0) @ t0) << (myY(id,y1) @ t1) = t0 < t1 .
  eq myDir(id,dir0) @ t0 << myDir(id,dir1) @ t1 = t0 < t1 .

  eq (clock(t0)) << (clock(t1)) = t0 < t1 .
  eq (energy(id,e0) @ t0) << (energy(id,e1) @ t1) =  t0 < t1 .
  eq (caution(id,e0) @ t0) << (caution(id,e1) @ t1) =  t0 < t1 .
  eq vel(id,ff0) @ t0 << vel(id,ff1) @ t1 = t0 < t1 .
  eq rand(id,r1:Nat) @ t0 << rand(id,r2:Nat) @ t1 = t0 < t1 .

  op atVEdge : Loc -> Bool .
  eq atVEdge({senl0,pt(x,y,z)}) =  ((x == 0) or (s x == edgeX))  . 
	
********* helpers
  op myActs : Class Id KB -> ActSet .
  eq myActs(cl, id,lkb) =
	  ( myMvs(cl,id,lkb)
		 (if canCharge(cl,id,lkb) then charge(id) else none fi)) .


**** at the same grid as a station and not fully charged 
  op canCharge : Class Id KB -> Bool .
  ceq canCharge(Bot,id,lkb) = true
	if (atloc(id,{senl0,gl0}) @ t0) class(id,Bot)
	   (atloc(id1,{senl1,gl0}) @ t1) class(id1,Station)
		 (energy(id,e) @ t2) lkb0 := lkb
  /\ e < maxCharge .

  eq canCharge(Bot,id,lkb) = false [owise] .

  op myMvs : Class Id KB -> ActSet .

	ceq myMvs(Bot,id, lkb) =
    ((if occupied(l0,lkb) then none else mv(id,E,v) fi)
     (if occupied(l1,lkb) then none else mv(id,W,v) fi)		
     (if occupied(l2,lkb) then none else mv(id,S,v) fi)				
     (if occupied(l3,lkb) then none else mv(id,N,v) fi)	)
   if l := getLoc(id,lkb)
   /\ v := getVel(id,lkb)
	 /\ l0 := doMv(l,E,v)
	 /\ l1 := doMv(l,W,v)
	 /\ l2 := doMv(l,S,v)
	 /\ l3 := doMv(l,N,v) .

	eq myMvs(cl,id,lkb) = none [owise] .

	op doAct : Id KB Action -> KB .
	
  ceq doAct(id,kb,charge(id)) = kb1
   if e0 := getEnergy(id,kb) + chargeUnit
   /\ e := min(e0, maxCharge)
   /\ t := getTime(kb)
   /\ kb1 := addK(kb, clock(s t) (energy(id,e) @ s t)) .

**** assume mv is valid
*** we have to collect from SITL
  ceq doAct(id,kb,mv(id,dir,v)) = kb1
   if e0 := getEnergy(id,kb) - costMv 
   /\ l0 := getLoc(id,kb)
   /\ l1 := doMv(l0,dir,v) 
   /\ t := getTime(kb)
   /\ kb1 := addK(kb, (clock(s t)) (atloc(id,l1) @ s t)
	                    (energy(id,e0) @ s t) ) .


  op cost2loc : Loc Loc -> FiniteFloat .
  eq cost2loc(l0,l1) = float(distance(l0,l1)) * costMv .

	
endfm
